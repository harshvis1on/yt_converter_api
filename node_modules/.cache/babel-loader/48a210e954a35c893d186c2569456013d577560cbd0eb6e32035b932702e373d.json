{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState, useCallback } from 'react';\nimport { createEpisodes } from '../services/n8nApi';\nimport { toast } from 'react-toastify';\nimport { safeGetItem } from '../utils/localStorage';\nexport function useYouTubeSync() {\n  _s();\n  const [state, setState] = useState({\n    loading: false,\n    error: null,\n    channel: null,\n    podcastId: null,\n    videos: [],\n    episodes: [],\n    progress: 0,\n    total: 0,\n    done: false,\n    status: '',\n    selectedVideos: []\n  });\n\n  // Load data from localStorage on mount\n  React.useEffect(() => {\n    const channelData = safeGetItem('channelData');\n    const videosData = safeGetItem('videosData', []);\n\n    // Try multiple sources for podcast ID\n    let podcastId = localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.megaphone_id) || (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.id);\n    }\n    if (channelData || (videosData === null || videosData === void 0 ? void 0 : videosData.length) > 0 || podcastId) {\n      setState(s => ({\n        ...s,\n        channel: channelData,\n        videos: videosData,\n        podcastId: podcastId || null\n      }));\n    }\n  }, []);\n\n  // Helper: is YouTube connected?\n  const isYouTubeConnected = !!(state.channel && state.channel.id);\n\n  // Connect YouTube data - re-fetch if not available\n  const connectYouTube = useCallback(async () => {\n    setState(s => ({\n      ...s,\n      loading: true,\n      error: null\n    }));\n    try {\n      // First check if data already exists in localStorage\n      let channel = safeGetItem('channelData');\n      let videos = safeGetItem('videosData', []);\n      const podcastId = localStorage.getItem('podcastId');\n\n      // If no YouTube data exists, we need to re-authenticate\n      if (!channel || !videos || videos.length === 0) {\n        console.log('ðŸ”„ No YouTube data found, need to re-authenticate...');\n\n        // Check if we have a Google token\n        const googleToken = localStorage.getItem('google_token');\n        if (!googleToken) {\n          throw new Error('No Google authentication found. Please sign in again.');\n        }\n\n        // Re-fetch YouTube data using existing token\n        const userInfo = safeGetItem('user_info', {});\n        if (!userInfo.id) {\n          throw new Error('User information not found. Please sign in again.');\n        }\n        console.log('ðŸ”„ Re-fetching YouTube data with existing token...');\n        const {\n          syncYouTubeChannel\n        } = await import('../services/n8nApi');\n        const result = await syncYouTubeChannel(googleToken, userInfo.id);\n        if (result && result.success) {\n          // Store the fetched data\n          localStorage.setItem('channelData', JSON.stringify(result.channel));\n          localStorage.setItem('videosData', JSON.stringify(result.videos));\n          channel = result.channel;\n          videos = result.videos;\n          console.log('âœ… YouTube data re-fetched successfully');\n        } else {\n          // Check if it's a token expiry issue\n          const errorMsg = (result === null || result === void 0 ? void 0 : result.message) || 'Failed to fetch YouTube data';\n          if (errorMsg.includes('401') || errorMsg.includes('Unauthorized') || errorMsg.includes('token') || errorMsg.includes('auth')) {\n            throw new Error('Google authentication expired. Please sign out and sign in again to refresh your YouTube connection.');\n          }\n          throw new Error(errorMsg);\n        }\n      }\n\n      // Try multiple sources for podcast ID - prioritize megaphone_id for API calls\n      let finalPodcastId = podcastId || localStorage.getItem('podcastId');\n      if (!finalPodcastId) {\n        const currentPodcast = safeGetItem('currentPodcast');\n        finalPodcastId = (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.megaphone_id) || (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.id);\n      }\n      setState(s => ({\n        ...s,\n        channel,\n        videos,\n        podcastId: finalPodcastId || null,\n        loading: false\n      }));\n      return {\n        channel,\n        videos,\n        podcastId,\n        success: true\n      };\n    } catch (error) {\n      console.error('âŒ Failed to connect YouTube:', error);\n      setState(s => ({\n        ...s,\n        error: error.message,\n        loading: false\n      }));\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }, []);\n\n  // Create episodes using n8n workflow\n  const syncToMegaphone = useCallback(async videos => {\n    if (!videos || videos.length === 0) {\n      toast.warning('No videos to sync');\n      return;\n    }\n    setState(s => ({\n      ...s,\n      loading: true,\n      progress: 0,\n      total: videos.length,\n      done: false,\n      episodes: [],\n      error: null,\n      // Clear any previous errors\n      status: 'Creating podcast episodes...'\n    }));\n\n    // Try multiple sources for podcast ID - prioritize megaphone_id for API calls\n    let podcastId = state.podcastId || localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.megaphone_id) || (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.id);\n    }\n    const userInfo = safeGetItem('user_info', {});\n    if (!podcastId) {\n      setState(s => ({\n        ...s,\n        error: 'No podcast ID found. Please ensure your podcast is properly set up.',\n        loading: false\n      }));\n      return;\n    }\n    try {\n      // Send full video objects with metadata instead of just IDs\n      const videoIds = videos.map(v => v.id || v.videoId).filter(Boolean);\n      const videoObjects = videos.map(v => ({\n        videoId: v.id || v.videoId,\n        title: v.title,\n        description: v.description,\n        publishedAt: v.publishedAt,\n        thumbnail: v.thumbnail,\n        duration: v.duration || null\n      }));\n      console.log('ðŸŽ¥ Creating episodes for videos:', videoIds);\n      console.log('ðŸ“Š Full video objects:', videoObjects);\n      console.log('ðŸ“‹ Using podcast ID:', podcastId);\n      console.log('ðŸ‘¤ Using user ID:', userInfo.id);\n\n      // Get user's podcast preference for audio/video from Supabase data\n      // FORCE fresh data from database - clear localStorage first\n      console.log('ðŸ§¹ Clearing localStorage podcast data to force fresh fetch...');\n      localStorage.removeItem('currentPodcast');\n      let currentPodcast = {};\n      console.log('ðŸ”„ FORCING fresh podcast data fetch from database...');\n      console.log('ðŸ” Looking for podcast with megaphone_id:', podcastId);\n      console.log('ðŸ‘¤ User ID:', userInfo.id);\n      try {\n        const {\n          getUserPodcasts\n        } = await import('../services/supabase');\n        const userPodcasts = await getUserPodcasts(userInfo.id);\n        console.log('ðŸ“Š All user podcasts from database:', userPodcasts);\n        console.log('ðŸ” Raw podcast data with distribution_type:', userPodcasts.map(p => ({\n          megaphone_id: p.megaphone_id,\n          distribution_type: p.distribution_type,\n          title: p.title\n        })));\n        const freshPodcast = userPodcasts.find(p => p.megaphone_id === podcastId);\n        console.log('ðŸŽ¯ Found matching podcast:', freshPodcast);\n        if (freshPodcast) {\n          console.log('ðŸ“ Fresh podcast distribution_type:', freshPodcast.distribution_type);\n          console.log('ðŸ“ Fresh podcast object keys:', Object.keys(freshPodcast));\n          currentPodcast = freshPodcast;\n          localStorage.setItem('currentPodcast', JSON.stringify(freshPodcast));\n          console.log('âœ… Refreshed podcast data from database and updated localStorage');\n        } else {\n          console.error('âŒ Podcast not found in database!');\n          console.log('ðŸ” Available podcast IDs:', userPodcasts.map(p => p.megaphone_id));\n          console.log('ðŸ” Looking for ID:', podcastId);\n          // Fallback to first podcast if exact match not found\n          if (userPodcasts.length > 0) {\n            currentPodcast = userPodcasts[0];\n            console.log('âš ï¸ Using first available podcast as fallback:', currentPodcast);\n          }\n        }\n      } catch (error) {\n        console.error('âŒ FAILED to refresh podcast data:', error);\n      }\n      console.log('ðŸ“Š Full currentPodcast object:', currentPodcast);\n      console.log('ðŸ” Checking distribution_type field:', currentPodcast.distribution_type);\n      console.log('ðŸ” Checking distributionType field:', currentPodcast.distributionType);\n      const distributionType = currentPodcast.distribution_type || currentPodcast.distributionType || 'audio'; // Check both field names, default to audio\n\n      console.log('ðŸŽ§ Final distribution type used:', distributionType);\n      console.log('â— ALERT: If this still shows \"audio\", check console for database logs above!');\n\n      // TEMPORARY MANUAL OVERRIDE FOR TESTING\n      const FORCE_VIDEO_MODE = true;\n      if (FORCE_VIDEO_MODE) {\n        console.log('ðŸ”¥ FORCING distribution type to \"video\" for testing!');\n        const finalDistributionType = 'video';\n        console.log('âœ… Overridden distribution type:', finalDistributionType);\n      } else {\n        const finalDistributionType = distributionType;\n      }\n\n      // Use finalDistributionType instead of distributionType\n      const finalDistributionType = FORCE_VIDEO_MODE ? 'video' : distributionType;\n\n      // Call n8n episode creation workflow with full video data\n      console.log('ðŸš€ About to call n8n createEpisodes API with full video data');\n      console.log('ðŸŽ¯ Using finalDistributionType:', finalDistributionType);\n      const result = await createEpisodes(podcastId, videoObjects, userInfo.id, finalDistributionType);\n      console.log('ðŸ“¤ createEpisodes result:', result);\n      if (result && result.success) {\n        const {\n          successful,\n          failed,\n          total\n        } = result.summary || {\n          successful: 0,\n          failed: 0,\n          total: 0\n        };\n\n        // Handle different response structures - n8n can return 'episodes' or 'results'\n        const episodeData = result.episodes || result.results || [];\n        console.log('ðŸ” Episode data found:', episodeData);\n\n        // Update state with episode results\n        const episodes = episodeData.map(r => ({\n          id: r.videoId,\n          title: r.title,\n          publishedAt: r.publishedAt || new Date().toISOString(),\n          mp4Url: `https://youtube.com/watch?v=${r.videoId}`,\n          publishedToMegaphone: r.status === 'created',\n          error: r.status === 'failed' ? 'Episode creation failed' : undefined\n        }));\n        setState(s => ({\n          ...s,\n          episodes,\n          progress: total,\n          total,\n          done: true,\n          loading: false,\n          status: `Sync complete! ${successful} successful, ${failed} failed`\n        }));\n\n        // Return the result with consistent structure\n        return {\n          ...result,\n          episodes: episodeData,\n          // Ensure episodes are accessible\n          results: episodeData // Keep both for backward compatibility\n        };\n      } else {\n        const errorMsg = (result === null || result === void 0 ? void 0 : result.error) || (result === null || result === void 0 ? void 0 : result.message) || 'Episode creation failed - no response from server';\n        console.error('âŒ Episode creation failed:', result);\n        throw new Error(errorMsg);\n      }\n    } catch (err) {\n      console.error('Episode creation process failed:', err);\n      setState(s => ({\n        ...s,\n        error: err.message,\n        loading: false,\n        status: '',\n        episodes: [],\n        // Clear any partial episodes on error\n        done: false\n      }));\n      toast.error('Episode creation failed: ' + err.message);\n      throw err;\n    }\n  }, [state.podcastId]);\n\n  // Video selection methods\n  const selectVideo = useCallback(videoId => {\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      if (currentSelected.includes(videoId)) {\n        return s; // Already selected, no change\n      }\n      return {\n        ...s,\n        selectedVideos: [...currentSelected, videoId]\n      };\n    });\n  }, []);\n  const deselectVideo = useCallback(videoId => {\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      if (!currentSelected.includes(videoId)) {\n        return s; // Not selected, no change\n      }\n      return {\n        ...s,\n        selectedVideos: currentSelected.filter(id => id !== videoId)\n      };\n    });\n  }, []);\n  const selectAllVideos = useCallback(videos => {\n    const videoIds = videos.map(v => v.id || v.videoId).filter(Boolean);\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      const newSelected = [...new Set([...currentSelected, ...videoIds])];\n      if (newSelected.length === currentSelected.length) {\n        return s; // No change\n      }\n      return {\n        ...s,\n        selectedVideos: newSelected\n      };\n    });\n  }, []);\n  const deselectAllVideos = useCallback(() => {\n    setState(s => {\n      if (!s.selectedVideos || s.selectedVideos.length === 0) {\n        return s; // Already empty, no change\n      }\n      return {\n        ...s,\n        selectedVideos: []\n      };\n    });\n  }, []);\n  const isVideoSelected = useCallback(videoId => {\n    return (state.selectedVideos || []).includes(videoId);\n  }, [state.selectedVideos]);\n  const handleCreateEpisodes = useCallback(async () => {\n    var _state$videos, _state$selectedVideos;\n    console.log('ðŸŽ¬ createEpisodes called in hook');\n    console.log('ðŸ“Š Current state:', {\n      videos: ((_state$videos = state.videos) === null || _state$videos === void 0 ? void 0 : _state$videos.length) || 0,\n      selectedVideos: ((_state$selectedVideos = state.selectedVideos) === null || _state$selectedVideos === void 0 ? void 0 : _state$selectedVideos.length) || 0,\n      selectedVideoIds: state.selectedVideos,\n      loading: state.loading\n    });\n\n    // Prevent duplicate calls if already loading\n    if (state.loading) {\n      console.log('â³ Episode creation already in progress, skipping duplicate call');\n      return;\n    }\n    const selectedVideoObjects = state.videos.filter(v => {\n      const videoId = v.id || v.videoId;\n      return state.selectedVideos.includes(videoId);\n    });\n    console.log('ðŸŽ¯ Filtered selectedVideoObjects:', selectedVideoObjects);\n    if (selectedVideoObjects.length === 0) {\n      console.warn('âš ï¸ No videos selected for episode creation');\n      throw new Error('No videos selected for episode creation');\n    }\n    console.log('ðŸ“ž Calling syncToMegaphone with', selectedVideoObjects.length, 'videos');\n    return await syncToMegaphone(selectedVideoObjects);\n  }, [state.videos, state.selectedVideos, state.loading, syncToMegaphone]);\n\n  // Refresh data from localStorage\n  const refreshData = useCallback(() => {\n    const channel = safeGetItem('channelData');\n    const videos = safeGetItem('videosData', []);\n\n    // Try multiple sources for podcast ID\n    let podcastId = localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.megaphone_id) || (currentPodcast === null || currentPodcast === void 0 ? void 0 : currentPodcast.id);\n    }\n    setState(s => ({\n      ...s,\n      channel,\n      videos,\n      podcastId: podcastId || null\n    }));\n  }, []);\n  return {\n    ...state,\n    connectYouTube,\n    syncToMegaphone,\n    isYouTubeConnected,\n    refreshData,\n    selectVideo,\n    deselectVideo,\n    selectAllVideos,\n    deselectAllVideos,\n    isVideoSelected,\n    createEpisodes: handleCreateEpisodes\n  };\n}\n_s(useYouTubeSync, \"cefODuQkfaSvu+iayJwQUEIoGBs=\");","map":{"version":3,"names":["React","useState","useCallback","createEpisodes","toast","safeGetItem","useYouTubeSync","_s","state","setState","loading","error","channel","podcastId","videos","episodes","progress","total","done","status","selectedVideos","useEffect","channelData","videosData","localStorage","getItem","currentPodcast","megaphone_id","id","length","s","isYouTubeConnected","connectYouTube","console","log","googleToken","Error","userInfo","syncYouTubeChannel","result","success","setItem","JSON","stringify","errorMsg","message","includes","finalPodcastId","syncToMegaphone","warning","videoIds","map","v","videoId","filter","Boolean","videoObjects","title","description","publishedAt","thumbnail","duration","removeItem","getUserPodcasts","userPodcasts","p","distribution_type","freshPodcast","find","Object","keys","distributionType","FORCE_VIDEO_MODE","finalDistributionType","successful","failed","summary","episodeData","results","r","Date","toISOString","mp4Url","publishedToMegaphone","undefined","err","selectVideo","currentSelected","deselectVideo","selectAllVideos","newSelected","Set","deselectAllVideos","isVideoSelected","handleCreateEpisodes","_state$videos","_state$selectedVideos","selectedVideoIds","selectedVideoObjects","warn","refreshData"],"sources":["/Users/harshdeshmukh/YouTube To Mp4 Links/src/hooks/useYouTubeSync.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\nimport { createEpisodes } from '../services/n8nApi';\nimport { toast } from 'react-toastify';\nimport { safeGetItem } from '../utils/localStorage';\n\n\nexport function useYouTubeSync() {\n  const [state, setState] = useState({\n    loading: false,\n    error: null,\n    channel: null,\n    podcastId: null,\n    videos: [],\n    episodes: [],\n    progress: 0,\n    total: 0,\n    done: false,\n    status: '',\n    selectedVideos: [],\n  });\n  \n  // Load data from localStorage on mount\n  React.useEffect(() => {\n    const channelData = safeGetItem('channelData');\n    const videosData = safeGetItem('videosData', []);\n    \n    // Try multiple sources for podcast ID\n    let podcastId = localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = currentPodcast?.megaphone_id || currentPodcast?.id;\n    }\n    \n    if (channelData || videosData?.length > 0 || podcastId) {\n      setState(s => ({\n        ...s,\n        channel: channelData,\n        videos: videosData,\n        podcastId: podcastId || null\n      }));\n    }\n  }, []);\n\n  // Helper: is YouTube connected?\n  const isYouTubeConnected = !!(state.channel && state.channel.id);\n\n  // Connect YouTube data - re-fetch if not available\n  const connectYouTube = useCallback(async () => {\n    setState(s => ({ ...s, loading: true, error: null }));\n    \n    try {\n      // First check if data already exists in localStorage\n      let channel = safeGetItem('channelData');\n      let videos = safeGetItem('videosData', []);\n      const podcastId = localStorage.getItem('podcastId');\n      \n      // If no YouTube data exists, we need to re-authenticate\n      if (!channel || !videos || videos.length === 0) {\n        console.log('ðŸ”„ No YouTube data found, need to re-authenticate...');\n        \n        // Check if we have a Google token\n        const googleToken = localStorage.getItem('google_token');\n        if (!googleToken) {\n          throw new Error('No Google authentication found. Please sign in again.');\n        }\n        \n        // Re-fetch YouTube data using existing token\n        const userInfo = safeGetItem('user_info', {});\n        if (!userInfo.id) {\n          throw new Error('User information not found. Please sign in again.');\n        }\n        \n        console.log('ðŸ”„ Re-fetching YouTube data with existing token...');\n        const { syncYouTubeChannel } = await import('../services/n8nApi');\n        const result = await syncYouTubeChannel(googleToken, userInfo.id);\n        \n        if (result && result.success) {\n          // Store the fetched data\n          localStorage.setItem('channelData', JSON.stringify(result.channel));\n          localStorage.setItem('videosData', JSON.stringify(result.videos));\n          \n          channel = result.channel;\n          videos = result.videos;\n          \n          console.log('âœ… YouTube data re-fetched successfully');\n        } else {\n          // Check if it's a token expiry issue\n          const errorMsg = result?.message || 'Failed to fetch YouTube data';\n          if (errorMsg.includes('401') || errorMsg.includes('Unauthorized') || \n              errorMsg.includes('token') || errorMsg.includes('auth')) {\n            throw new Error('Google authentication expired. Please sign out and sign in again to refresh your YouTube connection.');\n          }\n          throw new Error(errorMsg);\n        }\n      }\n      \n      // Try multiple sources for podcast ID - prioritize megaphone_id for API calls\n      let finalPodcastId = podcastId || localStorage.getItem('podcastId');\n      if (!finalPodcastId) {\n        const currentPodcast = safeGetItem('currentPodcast');\n        finalPodcastId = currentPodcast?.megaphone_id || currentPodcast?.id;\n      }\n      \n      setState(s => ({ \n        ...s, \n        channel, \n        videos, \n        podcastId: finalPodcastId || null, \n        loading: false \n      }));\n      \n      return { channel, videos, podcastId, success: true };\n      \n    } catch (error) {\n      console.error('âŒ Failed to connect YouTube:', error);\n      setState(s => ({ \n        ...s, \n        error: error.message, \n        loading: false \n      }));\n      return { success: false, error: error.message };\n    }\n  }, []);\n\n  // Create episodes using n8n workflow\n  const syncToMegaphone = useCallback(async (videos) => {\n    if (!videos || videos.length === 0) {\n      toast.warning('No videos to sync');\n      return;\n    }\n    \n    setState(s => ({ \n      ...s, \n      loading: true, \n      progress: 0, \n      total: videos.length, \n      done: false, \n      episodes: [], \n      error: null, // Clear any previous errors\n      status: 'Creating podcast episodes...' \n    }));\n    \n    // Try multiple sources for podcast ID - prioritize megaphone_id for API calls\n    let podcastId = state.podcastId || localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = currentPodcast?.megaphone_id || currentPodcast?.id;\n    }\n    \n    const userInfo = safeGetItem('user_info', {});\n    \n    if (!podcastId) {\n      setState(s => ({ ...s, error: 'No podcast ID found. Please ensure your podcast is properly set up.', loading: false }));\n      return;\n    }\n    \n    try {\n      // Send full video objects with metadata instead of just IDs\n      const videoIds = videos.map(v => v.id || v.videoId).filter(Boolean);\n      const videoObjects = videos.map(v => ({\n        videoId: v.id || v.videoId,\n        title: v.title,\n        description: v.description,\n        publishedAt: v.publishedAt,\n        thumbnail: v.thumbnail,\n        duration: v.duration || null\n      }));\n      \n      console.log('ðŸŽ¥ Creating episodes for videos:', videoIds);\n      console.log('ðŸ“Š Full video objects:', videoObjects);\n      console.log('ðŸ“‹ Using podcast ID:', podcastId);\n      console.log('ðŸ‘¤ Using user ID:', userInfo.id);\n      \n      // Get user's podcast preference for audio/video from Supabase data\n      // FORCE fresh data from database - clear localStorage first\n      console.log('ðŸ§¹ Clearing localStorage podcast data to force fresh fetch...');\n      localStorage.removeItem('currentPodcast');\n      \n      let currentPodcast = {};\n      \n      console.log('ðŸ”„ FORCING fresh podcast data fetch from database...');\n      console.log('ðŸ” Looking for podcast with megaphone_id:', podcastId);\n      console.log('ðŸ‘¤ User ID:', userInfo.id);\n      \n      try {\n        const { getUserPodcasts } = await import('../services/supabase');\n        const userPodcasts = await getUserPodcasts(userInfo.id);\n        console.log('ðŸ“Š All user podcasts from database:', userPodcasts);\n        console.log('ðŸ” Raw podcast data with distribution_type:', userPodcasts.map(p => ({ \n          megaphone_id: p.megaphone_id, \n          distribution_type: p.distribution_type, \n          title: p.title \n        })));\n        \n        const freshPodcast = userPodcasts.find(p => p.megaphone_id === podcastId);\n        console.log('ðŸŽ¯ Found matching podcast:', freshPodcast);\n        \n        if (freshPodcast) {\n          console.log('ðŸ“ Fresh podcast distribution_type:', freshPodcast.distribution_type);\n          console.log('ðŸ“ Fresh podcast object keys:', Object.keys(freshPodcast));\n          currentPodcast = freshPodcast;\n          localStorage.setItem('currentPodcast', JSON.stringify(freshPodcast));\n          console.log('âœ… Refreshed podcast data from database and updated localStorage');\n        } else {\n          console.error('âŒ Podcast not found in database!');\n          console.log('ðŸ” Available podcast IDs:', userPodcasts.map(p => p.megaphone_id));\n          console.log('ðŸ” Looking for ID:', podcastId);\n          // Fallback to first podcast if exact match not found\n          if (userPodcasts.length > 0) {\n            currentPodcast = userPodcasts[0];\n            console.log('âš ï¸ Using first available podcast as fallback:', currentPodcast);\n          }\n        }\n      } catch (error) {\n        console.error('âŒ FAILED to refresh podcast data:', error);\n      }\n      \n      console.log('ðŸ“Š Full currentPodcast object:', currentPodcast);\n      console.log('ðŸ” Checking distribution_type field:', currentPodcast.distribution_type);\n      console.log('ðŸ” Checking distributionType field:', currentPodcast.distributionType);\n      \n      const distributionType = currentPodcast.distribution_type || currentPodcast.distributionType || 'audio'; // Check both field names, default to audio\n      \n      console.log('ðŸŽ§ Final distribution type used:', distributionType);\n      console.log('â— ALERT: If this still shows \"audio\", check console for database logs above!');\n      \n      // TEMPORARY MANUAL OVERRIDE FOR TESTING\n      const FORCE_VIDEO_MODE = true;\n      if (FORCE_VIDEO_MODE) {\n        console.log('ðŸ”¥ FORCING distribution type to \"video\" for testing!');\n        const finalDistributionType = 'video';\n        console.log('âœ… Overridden distribution type:', finalDistributionType);\n      } else {\n        const finalDistributionType = distributionType;\n      }\n      \n      // Use finalDistributionType instead of distributionType\n      const finalDistributionType = FORCE_VIDEO_MODE ? 'video' : distributionType;\n      \n      // Call n8n episode creation workflow with full video data\n      console.log('ðŸš€ About to call n8n createEpisodes API with full video data');\n      console.log('ðŸŽ¯ Using finalDistributionType:', finalDistributionType);\n      const result = await createEpisodes(podcastId, videoObjects, userInfo.id, finalDistributionType);\n      \n      console.log('ðŸ“¤ createEpisodes result:', result);\n      \n      if (result && result.success) {\n        const { successful, failed, total } = result.summary || { successful: 0, failed: 0, total: 0 };\n        \n        // Handle different response structures - n8n can return 'episodes' or 'results'\n        const episodeData = result.episodes || result.results || [];\n        console.log('ðŸ” Episode data found:', episodeData);\n        \n        // Update state with episode results\n        const episodes = episodeData.map(r => ({\n          id: r.videoId,\n          title: r.title,\n          publishedAt: r.publishedAt || new Date().toISOString(),\n          mp4Url: `https://youtube.com/watch?v=${r.videoId}`,\n          publishedToMegaphone: r.status === 'created',\n          error: r.status === 'failed' ? 'Episode creation failed' : undefined\n        }));\n        \n        setState(s => ({ \n          ...s, \n          episodes, \n          progress: total, \n          total, \n          done: true, \n          loading: false, \n          status: `Sync complete! ${successful} successful, ${failed} failed` \n        }));\n        \n        // Return the result with consistent structure\n        return {\n          ...result,\n          episodes: episodeData, // Ensure episodes are accessible\n          results: episodeData   // Keep both for backward compatibility\n        };\n      } else {\n        const errorMsg = result?.error || result?.message || 'Episode creation failed - no response from server';\n        console.error('âŒ Episode creation failed:', result);\n        throw new Error(errorMsg);\n      }\n      \n    } catch (err) {\n      console.error('Episode creation process failed:', err);\n      setState(s => ({ \n        ...s, \n        error: err.message, \n        loading: false, \n        status: '', \n        episodes: [], // Clear any partial episodes on error\n        done: false \n      }));\n      toast.error('Episode creation failed: ' + err.message);\n      throw err;\n    }\n  }, [state.podcastId]);\n\n  // Video selection methods\n  const selectVideo = useCallback((videoId) => {\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      if (currentSelected.includes(videoId)) {\n        return s; // Already selected, no change\n      }\n      return {\n        ...s,\n        selectedVideos: [...currentSelected, videoId]\n      };\n    });\n  }, []);\n\n  const deselectVideo = useCallback((videoId) => {\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      if (!currentSelected.includes(videoId)) {\n        return s; // Not selected, no change\n      }\n      return {\n        ...s,\n        selectedVideos: currentSelected.filter(id => id !== videoId)\n      };\n    });\n  }, []);\n\n  const selectAllVideos = useCallback((videos) => {\n    const videoIds = videos.map(v => v.id || v.videoId).filter(Boolean);\n    setState(s => {\n      const currentSelected = s.selectedVideos || [];\n      const newSelected = [...new Set([...currentSelected, ...videoIds])];\n      if (newSelected.length === currentSelected.length) {\n        return s; // No change\n      }\n      return {\n        ...s,\n        selectedVideos: newSelected\n      };\n    });\n  }, []);\n\n  const deselectAllVideos = useCallback(() => {\n    setState(s => {\n      if (!s.selectedVideos || s.selectedVideos.length === 0) {\n        return s; // Already empty, no change\n      }\n      return {\n        ...s,\n        selectedVideos: []\n      };\n    });\n  }, []);\n\n  const isVideoSelected = useCallback((videoId) => {\n    return (state.selectedVideos || []).includes(videoId);\n  }, [state.selectedVideos]);\n\n  const handleCreateEpisodes = useCallback(async () => {\n    console.log('ðŸŽ¬ createEpisodes called in hook');\n    console.log('ðŸ“Š Current state:', {\n      videos: state.videos?.length || 0,\n      selectedVideos: state.selectedVideos?.length || 0,\n      selectedVideoIds: state.selectedVideos,\n      loading: state.loading\n    });\n    \n    // Prevent duplicate calls if already loading\n    if (state.loading) {\n      console.log('â³ Episode creation already in progress, skipping duplicate call');\n      return;\n    }\n    \n    const selectedVideoObjects = state.videos.filter(v => {\n      const videoId = v.id || v.videoId;\n      return state.selectedVideos.includes(videoId);\n    });\n    \n    console.log('ðŸŽ¯ Filtered selectedVideoObjects:', selectedVideoObjects);\n    \n    if (selectedVideoObjects.length === 0) {\n      console.warn('âš ï¸ No videos selected for episode creation');\n      throw new Error('No videos selected for episode creation');\n    }\n    \n    console.log('ðŸ“ž Calling syncToMegaphone with', selectedVideoObjects.length, 'videos');\n    return await syncToMegaphone(selectedVideoObjects);\n  }, [state.videos, state.selectedVideos, state.loading, syncToMegaphone]);\n\n  // Refresh data from localStorage\n  const refreshData = useCallback(() => {\n    const channel = safeGetItem('channelData');\n    const videos = safeGetItem('videosData', []);\n    \n    // Try multiple sources for podcast ID\n    let podcastId = localStorage.getItem('podcastId');\n    if (!podcastId) {\n      const currentPodcast = safeGetItem('currentPodcast');\n      podcastId = currentPodcast?.megaphone_id || currentPodcast?.id;\n    }\n    \n    setState(s => ({\n      ...s,\n      channel,\n      videos,\n      podcastId: podcastId || null\n    }));\n  }, []);\n\n  return {\n    ...state,\n    connectYouTube,\n    syncToMegaphone,\n    isYouTubeConnected,\n    refreshData,\n    selectVideo,\n    deselectVideo,\n    selectAllVideos,\n    deselectAllVideos,\n    isVideoSelected,\n    createEpisodes: handleCreateEpisodes,\n  };\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}