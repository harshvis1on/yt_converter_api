{"ast":null,"code":"// Clean n8n API service - replaces all direct API calls\nimport { toast } from 'react-toastify';\nimport { savePodcastDetails, savePayoutDetails } from './supabase';\n\n// n8n Configuration\nconst N8N_BASE_URL = process.env.REACT_APP_N8N_BASE_URL || 'https://n8n-6s78.onrender.com/';\nconst USE_TEST_WEBHOOKS = process.env.REACT_APP_USE_TEST_WEBHOOKS !== 'false'; // Default to true for testing\nconst DEV_MODE = process.env.REACT_APP_DEV_MODE === 'true';\n// Use mock mode only if explicitly enabled\nconst USE_MOCK_MODE = DEV_MODE;\nconsole.log('üîß n8n API Configuration:', {\n  N8N_BASE_URL,\n  USE_TEST_WEBHOOKS,\n  REACT_APP_DEV_MODE: process.env.REACT_APP_DEV_MODE,\n  NODE_ENV: process.env.NODE_ENV,\n  DEV_MODE,\n  USE_MOCK_MODE\n});\nclass N8nApiService {\n  constructor() {\n    this.baseURL = N8N_BASE_URL;\n    this.useTestWebhooks = USE_TEST_WEBHOOKS;\n  }\n  async makeRequest(endpoint, data) {\n    // Use direct n8n webhook URL - use test webhooks to avoid CORS issues\n    const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n    const targetUrl = `${baseUrl}/webhook-test/${endpoint}`;\n    console.log(`üì° Making request to endpoint: ${endpoint}`, {\n      USE_MOCK_MODE,\n      DEV_MODE,\n      n8nBaseUrl: baseUrl,\n      targetUrl,\n      payload: data\n    });\n\n    // Log the exact data being sent for debugging\n    console.log(`üîç Webhook payload for ${endpoint}:`, JSON.stringify(data, null, 2));\n\n    // Use mock mode if explicitly enabled\n    if (USE_MOCK_MODE) {\n      console.log(`üß™ Using mock response for ${endpoint}`);\n      return this.getMockResponse(endpoint, data);\n    }\n    try {\n      console.log(`üåê Calling n8n PRODUCTION webhook: ${targetUrl}`);\n\n      // Add timeout to prevent hanging\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n\n      const response = await fetch(targetUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data),\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`‚ùå HTTP ${response.status} error for ${endpoint}:`, errorText);\n        console.error(`üì§ Request was made to: ${targetUrl}`);\n        console.error(`üì¶ Request payload was:`, JSON.stringify(data, null, 2));\n\n        // For 404 errors in dev mode, fall back to mock (workflow not configured)  \n        if (DEV_MODE && response.status === 404) {\n          console.warn('üîÑ n8n workflow not found, falling back to mock response');\n          toast.info('Using offline mode - n8n workflow not configured');\n          return this.getMockResponse(endpoint, data);\n        }\n\n        // Only fall back to mock for server errors in dev mode\n        if (DEV_MODE && response.status >= 500) {\n          console.warn('Server error in dev mode, falling back to mock response');\n          return this.getMockResponse(endpoint, data);\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);\n      }\n\n      // Check if response has content before parsing JSON\n      const responseText = await response.text();\n      console.log(`üì• Raw response from ${endpoint}:`, responseText);\n      if (!responseText || responseText.trim() === '') {\n        console.warn(`‚ö†Ô∏è Empty response from ${endpoint}, falling back to mock`);\n        toast.info('Webhook returned empty response - using offline mode');\n        return this.getMockResponse(endpoint, data);\n      }\n      let result;\n      try {\n        result = JSON.parse(responseText);\n        console.log(`‚úÖ Parsed JSON from ${endpoint}:`, result);\n      } catch (parseError) {\n        console.error(`‚ùå JSON parse error for ${endpoint}:`, parseError);\n        console.error(`üìù Response text was:`, responseText);\n        console.warn('üîÑ Falling back to mock response due to parse error');\n        toast.info('Webhook returned invalid response - using offline mode');\n        return this.getMockResponse(endpoint, data);\n      }\n\n      // Handle N8N array response format\n      const finalResult = Array.isArray(result) ? result[0] : result;\n      console.log(`Processed response:`, finalResult);\n\n      // Handle different response formats from n8n workflow\n      if (endpoint === 'youtube-sync') {\n        // Check if it's already in the expected format\n        if (finalResult.success && finalResult.channel && finalResult.videos) {\n          console.log('‚úÖ Received properly formatted YouTube sync response');\n          return finalResult;\n        }\n\n        // Handle raw YouTube API response format\n        if (Array.isArray(finalResult) && !finalResult.success) {\n          console.warn('‚ö†Ô∏è n8n returned raw YouTube data, transforming...');\n          return this.transformYouTubeResponse(finalResult);\n        }\n\n        // Handle single object response format\n        if (finalResult.channel || finalResult.videos || finalResult.items) {\n          console.warn('‚ö†Ô∏è n8n returned partial data format, transforming...');\n          return this.transformYouTubeResponse([finalResult]);\n        }\n      }\n      return finalResult;\n    } catch (error) {\n      console.error(`n8n API error for ${endpoint}:`, error);\n\n      // Fall back to mock for network/CORS failures (common in development)\n      if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('CORS') || error.name === 'AbortError' || error.message.includes('fetch')) {\n        console.warn('üîÑ Network/CORS error, falling back to mock response');\n        toast.info('Using offline mode - n8n server not available or CORS issue');\n        return this.getMockResponse(endpoint, data);\n      }\n\n      // Better error messages\n      if (error.message.includes('HTTP 404')) {\n        throw new Error('Workflow not found. Please ensure n8n workflows are properly set up.');\n      } else if (error.message.includes('HTTP 500')) {\n        throw new Error('Server error occurred. Please try again in a moment.');\n      } else {\n        throw new Error(`n8n workflow failed: ${error.message}`);\n      }\n    }\n  }\n\n  // Mock responses for development\n  getMockResponse(endpoint, data) {\n    var _data$title, _data$userInfo;\n    console.log(`üß™ Using mock response for ${endpoint}`);\n    switch (endpoint) {\n      case 'youtube-sync':\n        return {\n          success: true,\n          channel: {\n            id: 'UC_mock_channel_id',\n            title: 'Mock YouTube Channel',\n            description: 'This is a mock YouTube channel for testing purposes.',\n            subscriberCount: '1234',\n            videoCount: '42'\n          },\n          videos: [{\n            videoId: 'mock_video_1',\n            title: 'Mock Video 1: Introduction to PodPay',\n            description: 'Learn how to use PodPay to convert YouTube videos to podcasts.',\n            publishedAt: new Date(Date.now() - 86400000).toISOString(),\n            thumbnail: 'https://via.placeholder.com/120x90/4F46E5/FFFFFF?text=Video+1'\n          }, {\n            videoId: 'mock_video_2',\n            title: 'Mock Video 2: Advanced Features',\n            description: 'Explore advanced features of podcast creation.',\n            publishedAt: new Date(Date.now() - 172800000).toISOString(),\n            thumbnail: 'https://via.placeholder.com/120x90/7C3AED/FFFFFF?text=Video+2'\n          }, {\n            videoId: 'mock_video_3',\n            title: 'Mock Video 3: Monetization Tips',\n            description: 'Tips and tricks for monetizing your podcast.',\n            publishedAt: new Date(Date.now() - 259200000).toISOString(),\n            thumbnail: 'https://via.placeholder.com/120x90/059669/FFFFFF?text=Video+3'\n          }],\n          message: 'Mock YouTube channel data fetched successfully - ready for podcast creation form',\n          prefillData: {\n            title: 'Mock YouTube Channel Podcast',\n            subtitle: 'Podcast created from Mock YouTube Channel',\n            summary: 'This is a mock YouTube channel for testing purposes.',\n            author: 'Mock YouTube Channel',\n            link: 'https://www.youtube.com/channel/UC_mock_channel_id',\n            language: 'en',\n            itunesCategories: ['Technology'],\n            explicit: 'clean',\n            podcastType: 'serial',\n            imageFile: 'https://via.placeholder.com/300x300/4F46E5/FFFFFF?text=Mock+Channel'\n          }\n        };\n      case 'create-podcast':\n        return {\n          success: true,\n          podcastId: 'mock_podcast_' + Date.now(),\n          podcast: {\n            id: 'mock_podcast_' + Date.now(),\n            title: data.title || 'Mock Podcast',\n            description: data.description || 'Mock podcast description',\n            author: data.author || 'Mock Author',\n            language: data.language || 'en',\n            explicit: data.explicit || 'clean',\n            primaryCategory: data.primaryCategory || 'Technology',\n            secondaryCategory: data.secondaryCategory || '',\n            podcastType: data.podcastType || 'serial',\n            link: data.link || 'https://youtube.com/channel/mock',\n            copyright: data.copyright || '¬© 2024 Mock Author',\n            ownerName: data.ownerName || 'Mock Author',\n            ownerEmail: data.ownerEmail || 'mock@example.com',\n            websiteUrl: data.websiteUrl || 'https://youtube.com/channel/mock',\n            keywords: data.keywords || 'mock, podcast, youtube',\n            slug: ((_data$title = data.title) === null || _data$title === void 0 ? void 0 : _data$title.toLowerCase().replace(/[^a-z0-9]+/g, '-')) || 'mock-podcast',\n            createdAt: new Date().toISOString(),\n            feedUrl: `https://feeds.megaphone.fm/mock_podcast_${Date.now()}`\n          },\n          message: 'Mock podcast created successfully!'\n        };\n      case 'sync-podcast-data':\n        return {\n          success: true,\n          podcast: {\n            title: 'Harsh ‚òÄÔ∏è Podcast',\n            subtitle: 'Updated from Megaphone',\n            summary: 'Fresh podcast data synced from Megaphone API',\n            episodes_count: 0,\n            status: 'active'\n          },\n          message: 'Podcast data synced from Megaphone'\n        };\n      case 'sync-megaphone-episodes':\n        return {\n          success: true,\n          episodeCount: 0,\n          episodes: [],\n          message: 'No episodes found in Megaphone for this podcast'\n        };\n      case 'fetch-episodes':\n        return {\n          success: true,\n          episodes: [{\n            id: 'episode_1',\n            title: 'Sample Published Episode 1',\n            summary: 'This is a sample episode summary',\n            publishedAt: '2025-01-20T10:00:00Z',\n            duration: 1800,\n            // 30 minutes in seconds\n            status: 'published',\n            playCount: 1234,\n            downloadCount: 567,\n            fileUrl: 'https://example.com/episode1.mp3'\n          }, {\n            id: 'episode_2',\n            title: 'Sample Published Episode 2',\n            summary: 'This is another sample episode summary',\n            publishedAt: '2025-01-15T10:00:00Z',\n            duration: 2100,\n            // 35 minutes in seconds\n            status: 'published',\n            playCount: 987,\n            downloadCount: 432,\n            fileUrl: 'https://example.com/episode2.mp3'\n          }],\n          totalCount: 2\n        };\n      case 'create-episodes':\n        const videoIds = data.videoIds || [];\n        return {\n          success: true,\n          results: videoIds.map(videoId => ({\n            videoId,\n            episodeId: `mock_episode_${videoId}`,\n            status: 'created',\n            title: `Mock Episode for ${videoId}`\n          })),\n          summary: {\n            total: videoIds.length,\n            successful: videoIds.length,\n            failed: 0\n          },\n          episodesSaved: videoIds.map(videoId => ({\n            id: `episode_${videoId}`,\n            title: `Episode from video ${videoId}`,\n            status: 'published',\n            created_at: new Date().toISOString()\n          }))\n        };\n      case 'user-setup':\n        return {\n          success: true,\n          userId: ((_data$userInfo = data.userInfo) === null || _data$userInfo === void 0 ? void 0 : _data$userInfo.id) || 'mock_user_123',\n          message: 'Mock user setup completed'\n        };\n      default:\n        return {\n          success: true,\n          message: `Mock response for ${endpoint}`\n        };\n    }\n  }\n\n  // Transform raw YouTube API response into expected format\n  transformYouTubeResponse(rawData) {\n    console.log('üîÑ Transforming raw YouTube response to expected format');\n    try {\n      var _firstVideo$snippet$t, _firstVideo$snippet$t2, _firstVideo$snippet$t3, _firstVideo$snippet$t4, _firstVideo$snippet$t5, _firstVideo$snippet$t6;\n      // Extract the first item which contains the playlist data\n      const playlistData = rawData[0];\n      if (!playlistData || !playlistData.items) {\n        throw new Error('Invalid YouTube response structure');\n      }\n\n      // Extract channel info from the first video\n      const firstVideo = playlistData.items[0];\n      if (!firstVideo) {\n        throw new Error('No videos found in playlist');\n      }\n\n      // Create channel object\n      const channel = {\n        id: firstVideo.snippet.channelId,\n        title: firstVideo.snippet.channelTitle,\n        description: `YouTube channel with ${playlistData.pageInfo.totalResults} videos`,\n        subscriberCount: 'N/A',\n        // Not available in playlist response\n        videoCount: playlistData.pageInfo.totalResults.toString(),\n        thumbnail: ((_firstVideo$snippet$t = firstVideo.snippet.thumbnails) === null || _firstVideo$snippet$t === void 0 ? void 0 : (_firstVideo$snippet$t2 = _firstVideo$snippet$t.high) === null || _firstVideo$snippet$t2 === void 0 ? void 0 : _firstVideo$snippet$t2.url) || ((_firstVideo$snippet$t3 = firstVideo.snippet.thumbnails) === null || _firstVideo$snippet$t3 === void 0 ? void 0 : (_firstVideo$snippet$t4 = _firstVideo$snippet$t3.medium) === null || _firstVideo$snippet$t4 === void 0 ? void 0 : _firstVideo$snippet$t4.url) || ((_firstVideo$snippet$t5 = firstVideo.snippet.thumbnails) === null || _firstVideo$snippet$t5 === void 0 ? void 0 : (_firstVideo$snippet$t6 = _firstVideo$snippet$t5.default) === null || _firstVideo$snippet$t6 === void 0 ? void 0 : _firstVideo$snippet$t6.url)\n      };\n\n      // Transform videos\n      const videos = playlistData.items.map(item => {\n        var _item$snippet$thumbna, _item$snippet$thumbna2, _item$snippet$thumbna3, _item$snippet$thumbna4, _item$snippet$thumbna5, _item$snippet$thumbna6, _item$snippet$thumbna7, _item$snippet$thumbna8;\n        return {\n          videoId: item.snippet.resourceId.videoId,\n          title: item.snippet.title,\n          description: item.snippet.description,\n          publishedAt: item.snippet.publishedAt,\n          thumbnail: ((_item$snippet$thumbna = item.snippet.thumbnails) === null || _item$snippet$thumbna === void 0 ? void 0 : (_item$snippet$thumbna2 = _item$snippet$thumbna.maxres) === null || _item$snippet$thumbna2 === void 0 ? void 0 : _item$snippet$thumbna2.url) || ((_item$snippet$thumbna3 = item.snippet.thumbnails) === null || _item$snippet$thumbna3 === void 0 ? void 0 : (_item$snippet$thumbna4 = _item$snippet$thumbna3.high) === null || _item$snippet$thumbna4 === void 0 ? void 0 : _item$snippet$thumbna4.url) || ((_item$snippet$thumbna5 = item.snippet.thumbnails) === null || _item$snippet$thumbna5 === void 0 ? void 0 : (_item$snippet$thumbna6 = _item$snippet$thumbna5.medium) === null || _item$snippet$thumbna6 === void 0 ? void 0 : _item$snippet$thumbna6.url) || ((_item$snippet$thumbna7 = item.snippet.thumbnails) === null || _item$snippet$thumbna7 === void 0 ? void 0 : (_item$snippet$thumbna8 = _item$snippet$thumbna7.default) === null || _item$snippet$thumbna8 === void 0 ? void 0 : _item$snippet$thumbna8.url),\n          position: item.snippet.position\n        };\n      });\n\n      // Create prefill data with Megaphone-compatible fields\n      const prefillData = {\n        title: channel.title + ' Podcast',\n        subtitle: `Podcast created from ${channel.title} YouTube channel`,\n        // New Megaphone field\n        summary: channel.description || `Podcast created from ${channel.title} YouTube channel with ${channel.videoCount} videos.`,\n        // Megaphone uses 'summary'\n        author: channel.title,\n        link: `https://www.youtube.com/channel/${channel.id}`,\n        language: 'en',\n        itunesCategories: ['Technology'],\n        // Convert to iTunes categories array\n        explicit: 'clean',\n        // Megaphone enum: no/clean/yes\n        podcastType: 'serial',\n        copyright: `¬© ${new Date().getFullYear()} ${channel.title}`,\n        ownerName: channel.title,\n        ownerEmail: '',\n        // User will need to fill this\n        imageFile: channel.thumbnail || '',\n        // Megaphone uses 'imageFile' instead of 'artworkUrl'\n        keywords: 'youtube, podcast, ' + channel.title.toLowerCase().replace(/\\s+/g, ', ')\n      };\n      const transformedResponse = {\n        success: true,\n        channel,\n        videos,\n        message: 'YouTube channel data fetched successfully - ready for podcast creation form',\n        prefillData\n      };\n      console.log('‚úÖ Successfully transformed YouTube response:', {\n        channelTitle: channel.title,\n        videoCount: videos.length,\n        hasPreffillData: !!prefillData\n      });\n      return transformedResponse;\n    } catch (error) {\n      var _rawData$, _rawData$$items;\n      console.error('‚ùå Failed to transform YouTube response:', error);\n\n      // Return fallback response\n      return {\n        success: true,\n        channel: {\n          id: 'unknown',\n          title: 'YouTube Channel',\n          description: 'Channel data retrieved from YouTube',\n          subscriberCount: 'N/A',\n          videoCount: Array.isArray(rawData) && (_rawData$ = rawData[0]) !== null && _rawData$ !== void 0 && (_rawData$$items = _rawData$.items) !== null && _rawData$$items !== void 0 && _rawData$$items.length ? rawData[0].items.length.toString() : '0'\n        },\n        videos: [],\n        message: 'YouTube channel data retrieved (with limited info)',\n        prefillData: {\n          title: 'My YouTube Podcast',\n          subtitle: 'Podcast created from YouTube channel',\n          summary: 'Podcast created from YouTube channel content',\n          author: 'YouTube Creator',\n          link: 'https://youtube.com',\n          language: 'en',\n          itunesCategories: ['Technology'],\n          explicit: 'clean',\n          podcastType: 'serial',\n          imageFile: ''\n        }\n      };\n    }\n  }\n\n  // YouTube Channel Sync - fetches channel data for form prefill\n  async syncYouTubeChannel(accessToken, userId) {\n    try {\n      console.log(`üéØ syncYouTubeChannel called with:`, {\n        accessToken: accessToken ? `${accessToken.substring(0, 10)}...` : 'NULL',\n        userId: userId || 'NULL'\n      });\n      toast.info('Fetching your YouTube channel data...');\n      const result = await this.makeRequest('youtube-sync', {\n        accessToken,\n        userId\n      });\n      if (result.success) {\n        var _result$channel;\n        const channelTitle = ((_result$channel = result.channel) === null || _result$channel === void 0 ? void 0 : _result$channel.title) || 'Your Channel';\n        toast.success(`Channel \"${channelTitle}\" data fetched successfully!`);\n        return result;\n      } else {\n        throw new Error(result.error || result.message || 'Channel sync failed');\n      }\n    } catch (error) {\n      console.error('YouTube channel sync failed:', error);\n      throw error;\n    }\n  }\n\n  // Create Podcast - creates podcast after user fills form\n  async createPodcast(podcastData) {\n    try {\n      var _podcastData$customAr;\n      toast.info('Creating your podcast...');\n\n      // Ensure all required data is included\n      const podcastPayload = {\n        ...podcastData,\n        // Add timestamp for uniqueness\n        createdAt: new Date().toISOString(),\n        // Ensure required fields have defaults\n        language: podcastData.language || 'en',\n        explicit: podcastData.explicit || 'clean',\n        podcastType: podcastData.podcastType || 'serial',\n        primaryCategory: podcastData.primaryCategory || 'Technology',\n        // Ensure imageFile is set from the best available source\n        imageFile: podcastData.imageFile || podcastData.finalArtworkUrl || podcastData.backgroundImageFileUrl || ((_podcastData$customAr = podcastData.customArtwork) === null || _podcastData$customAr === void 0 ? void 0 : _podcastData$customAr.supabaseUrl)\n      };\n      console.log('Creating podcast with payload:', podcastPayload);\n      console.log('üì∏ Image data being sent to n8n:', {\n        imageFile: podcastPayload.imageFile,\n        backgroundImageFileUrl: podcastPayload.backgroundImageFileUrl,\n        finalArtworkUrl: podcastPayload.finalArtworkUrl\n      });\n      const result = await this.makeRequest('create-podcast', podcastPayload);\n      if (result.success) {\n        var _result$payout;\n        // Save podcast details to Supabase (if not already saved via N8N workflow)\n        try {\n          var _result$ids;\n          const userId = podcastPayload.userId;\n          const megaphoneResponse = result.podcast || result.megaphoneResponse;\n\n          // Only save to Supabase if N8N didn't already handle it\n          if (megaphoneResponse && !((_result$ids = result.ids) !== null && _result$ids !== void 0 && _result$ids.supabaseId)) {\n            console.log('üíæ Saving podcast to Supabase...', megaphoneResponse);\n            const supabasePodcast = await savePodcastDetails(userId, podcastPayload, megaphoneResponse);\n\n            // Store Supabase podcast ID for payout linking\n            result.supabasePodcastId = supabasePodcast.id;\n            result.supabasePodcast = supabasePodcast;\n            console.log('‚úÖ Podcast saved to Supabase:', supabasePodcast.id);\n          } else {\n            console.log('‚úÖ Podcast already saved to Supabase via N8N workflow');\n          }\n        } catch (supabaseError) {\n          console.error('‚ùå Failed to save podcast to Supabase:', supabaseError);\n          // Continue with workflow - sometimes the save actually succeeds despite error message\n          console.log('‚ÑπÔ∏è Check Supabase directly - data might have saved successfully');\n        }\n\n        // Check if there were any Airwallex errors but still continue\n        if (result.airwallexError || ((_result$payout = result.payout) === null || _result$payout === void 0 ? void 0 : _result$payout.status) === 'incomplete') {\n          console.warn('‚ö†Ô∏è Airwallex beneficiary creation failed:', result.airwallexError);\n          toast.warning('Podcast created! Payout setup needs attention - check dashboard later.');\n\n          // Save failed payout details to Supabase if we have podcast ID\n          if (result.supabasePodcastId && podcastPayload.payoutData) {\n            try {\n              await savePayoutDetails(podcastPayload.userId, result.supabasePodcastId, {\n                ...podcastPayload.payoutData,\n                status: 'error',\n                error_message: result.airwallexError\n              });\n            } catch (payoutSaveError) {\n              console.error('‚ùå Failed to save payout error to Supabase:', payoutSaveError);\n            }\n          }\n          return {\n            ...result,\n            payoutSetupIncomplete: true,\n            payoutError: result.airwallexError\n          };\n        } else {\n          // Save successful payout details to Supabase\n          if (result.supabasePodcastId && podcastPayload.payoutData && result.airwallexBeneficiaryId) {\n            try {\n              await savePayoutDetails(podcastPayload.userId, result.supabasePodcastId, {\n                ...podcastPayload.payoutData,\n                airwallexBeneficiaryId: result.airwallexBeneficiaryId,\n                status: 'active'\n              });\n              console.log('‚úÖ Payout details saved to Supabase');\n            } catch (payoutSaveError) {\n              console.error('‚ùå Failed to save payout details to Supabase:', payoutSaveError);\n            }\n          }\n          toast.success(`Podcast \"${podcastData.title}\" created successfully!`);\n        }\n        return result;\n      } else {\n        throw new Error(result.error || result.message || 'Podcast creation failed');\n      }\n    } catch (error) {\n      console.error('Podcast creation failed:', error);\n      throw error;\n    }\n  }\n\n  // Podcast Data Sync Methods\n  async syncPodcastDataFromMegaphone(userId) {\n    try {\n      console.log('üîÑ syncPodcastDataFromMegaphone called for user:', userId);\n      const result = await this.makeRequest('sync-podcast-data', {\n        userId\n      });\n      if (result.success) {\n        console.log(`‚úÖ Synced podcast data from Megaphone:`, result.podcast);\n        return {\n          success: true,\n          podcast: result.podcast,\n          message: result.message || 'Podcast data synced successfully'\n        };\n      } else {\n        throw new Error(result.error || 'Failed to sync podcast data from Megaphone');\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Podcast data sync failed (non-critical):', error.message);\n\n      // Return success for missing webhooks to avoid blocking auth flow\n      if (error.message.includes('Failed to fetch') || error.message.includes('CORS') || error.message.includes('404')) {\n        console.log('üìù Sync webhook not available, skipping sync (this is okay)');\n        return {\n          success: true,\n          message: 'Podcast sync skipped - webhook not available'\n        };\n      }\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Episode Management Methods\n  async syncMegaphoneEpisodes(podcastId, userId) {\n    try {\n      console.log('üîÑ syncMegaphoneEpisodes called with:', {\n        podcastId,\n        userId\n      });\n      const result = await this.makeRequest('sync-megaphone-episodes', {\n        podcastId,\n        userId\n      });\n      if (result.success) {\n        console.log(`‚úÖ Synced ${result.episodeCount || 0} episodes from Megaphone`);\n        return {\n          success: true,\n          episodes: result.episodes || [],\n          episodeCount: result.episodeCount || 0,\n          message: result.message || 'Episodes synced successfully'\n        };\n      } else {\n        throw new Error(result.error || 'Failed to sync episodes from Megaphone');\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Megaphone episodes sync failed (non-critical):', error.message);\n\n      // Return empty episodes list for missing webhooks\n      if (error.message.includes('Failed to fetch') || error.message.includes('CORS') || error.message.includes('404')) {\n        console.log('üìù Megaphone sync webhook not available, returning empty episodes');\n        return {\n          success: true,\n          episodes: [],\n          episodeCount: 0,\n          message: 'Megaphone sync skipped - webhook not available'\n        };\n      }\n      return {\n        success: false,\n        error: error.message,\n        episodes: []\n      };\n    }\n  }\n  async fetchEpisodes(podcastId, userId) {\n    try {\n      console.log('üéØ fetchEpisodes called with:', {\n        podcastId,\n        userId\n      });\n      const result = await this.makeRequest('fetch-episodes', {\n        podcastId,\n        userId\n      });\n      if (result.success) {\n        var _result$episodes;\n        console.log(`‚úÖ Fetched ${((_result$episodes = result.episodes) === null || _result$episodes === void 0 ? void 0 : _result$episodes.length) || 0} episodes from Megaphone`);\n        return {\n          success: true,\n          episodes: result.episodes || [],\n          totalCount: result.totalCount || 0\n        };\n      } else {\n        throw new Error(result.error || 'Failed to fetch episodes');\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Fetch episodes failed (non-critical):', error.message);\n\n      // Return empty episodes list for missing webhooks\n      if (error.message.includes('Failed to fetch') || error.message.includes('CORS') || error.message.includes('404')) {\n        console.log('üìù Fetch episodes webhook not available, returning empty episodes');\n        return {\n          success: true,\n          episodes: [],\n          totalCount: 0,\n          message: 'Episode fetch skipped - webhook not available'\n        };\n      }\n      return {\n        success: false,\n        error: error.message,\n        episodes: []\n      };\n    }\n  }\n\n  // Episode Creation - creates episodes and saves to Supabase\n  async createEpisodes(podcastId, videoIds, userId) {\n    console.log('üî• createEpisodes function called with:', {\n      podcastId,\n      videoIds,\n      userId\n    });\n    try {\n      // Validate inputs\n      if (!podcastId) {\n        throw new Error('No podcastId provided');\n      }\n      if (!videoIds || videoIds.length === 0) {\n        throw new Error('No videoIds provided');\n      }\n      if (!userId) {\n        throw new Error('No userId provided');\n      }\n      toast.info(`Creating ${videoIds.length} episodes and saving to database...`);\n\n      // For create-episodes, use the test webhook endpoint directly\n      const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n      const testWebhookUrl = `${baseUrl}/webhook-test/create-episodes`;\n      console.log('üì§ Sending episode creation request to:', testWebhookUrl);\n      console.log('üìã Payload:', {\n        podcastId,\n        videoIds,\n        userId\n      });\n\n      // Check if we should use mock mode\n      if (USE_MOCK_MODE) {\n        console.log('üß™ Using mock response for create-episodes');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n      const response = await fetch(testWebhookUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        })\n      });\n      console.log('üì° Response status:', response.status);\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('‚ùå HTTP Error:', response.status, errorText);\n\n        // If webhook doesn't exist (404), fall back to mock data\n        if (response.status === 404 || DEV_MODE) {\n          console.warn('üîÑ Test webhook not found or in dev mode, using mock response');\n          const result = this.getMockResponse('create-episodes', {\n            podcastId,\n            videoIds,\n            userId,\n            saveToSupabase: true\n          });\n          return result;\n        }\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      const responseText = await response.text();\n      console.log('üì• Raw response:', responseText);\n      if (!responseText || responseText.trim() === '') {\n        console.warn('‚ö†Ô∏è Empty response from webhook, using mock data');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n      let result;\n      try {\n        result = JSON.parse(responseText);\n        console.log('‚úÖ Episode creation response:', result);\n      } catch (parseError) {\n        console.error('‚ùå JSON parse error:', parseError);\n        console.warn('üîÑ Using mock response due to parse error');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n\n      // Handle n8n workflow started response\n      if (result.message === 'Workflow was started' || !result.success) {\n        console.warn('üîÑ n8n workflow started but no detailed response - using mock fallback');\n        toast.info('Episode creation workflow started - using mock response for now');\n        const mockResult = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return mockResult;\n      }\n      console.log('‚úÖ Episode creation response:', result);\n      if (result && result.success) {\n        const {\n          successful,\n          failed,\n          total\n        } = result.summary || {\n          successful: videoIds.length,\n          failed: 0,\n          total: videoIds.length\n        };\n        if (successful > 0) {\n          toast.success(`${successful}/${total} episodes created and saved to database!`);\n        }\n        if (failed > 0) {\n          toast.warning(`${failed}/${total} episodes failed to create`);\n        }\n\n        // Also sync existing episodes to ensure we have everything\n        setTimeout(() => {\n          this.syncMegaphoneEpisodes(podcastId, userId);\n        }, 2000);\n        const finalResult = {\n          ...result,\n          episodesSaved: result.episodesSaved || []\n        };\n        console.log('üéâ createEpisodes returning success result:', finalResult);\n        return finalResult;\n      } else {\n        var _result, _result2;\n        console.error('‚ùå Episode creation result was not successful:', result);\n        throw new Error(((_result = result) === null || _result === void 0 ? void 0 : _result.error) || ((_result2 = result) === null || _result2 === void 0 ? void 0 : _result2.message) || 'Episode creation failed');\n      }\n    } catch (error) {\n      console.error('üö® createEpisodes function error:', error);\n      toast.error(`Episode creation failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  // User Setup - handles user data storage\n  async setupUser(googleToken, userInfo) {\n    try {\n      console.log('Setting up user with n8n...');\n      const result = await this.makeRequest('user-setup', {\n        googleToken,\n        userInfo\n      });\n      if (result.success) {\n        console.log('User setup completed:', result);\n        return result;\n      } else {\n        throw new Error(result.error || 'User setup failed');\n      }\n    } catch (error) {\n      console.error('User setup failed:', error);\n      // Don't show error toast for user setup - it's background\n      throw error;\n    }\n  }\n\n  // Health check for n8n connection\n  async healthCheck() {\n    // Mock mode always returns healthy\n    if (USE_MOCK_MODE) {\n      return true;\n    }\n    try {\n      // Use production webhooks for health check\n      const webhookPath = 'webhook';\n      const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n      const healthUrl = `${baseUrl}/${webhookPath}/health`;\n      const response = await fetch(healthUrl);\n      return response.ok;\n    } catch {\n      // Fall back to mock mode if health check fails\n      return true; // Allow the app to work with mocks\n    }\n  }\n}\n\n// Export singleton instance\nexport const n8nApi = new N8nApiService();\n\n// Export individual functions for convenience\nexport const syncYouTubeChannel = (accessToken, userId) => n8nApi.syncYouTubeChannel(accessToken, userId);\nexport const createPodcast = podcastData => n8nApi.createPodcast(podcastData);\nexport const syncPodcastDataFromMegaphone = userId => n8nApi.syncPodcastDataFromMegaphone(userId);\nexport const syncMegaphoneEpisodes = (podcastId, userId) => n8nApi.syncMegaphoneEpisodes(podcastId, userId);\nexport const fetchEpisodes = (podcastId, userId) => n8nApi.fetchEpisodes(podcastId, userId);\nexport const createEpisodes = (podcastId, videoIds, userId) => n8nApi.createEpisodes(podcastId, videoIds, userId);\nexport const setupUser = (googleToken, userInfo) => n8nApi.setupUser(googleToken, userInfo);\nexport default n8nApi;","map":{"version":3,"names":["toast","savePodcastDetails","savePayoutDetails","N8N_BASE_URL","process","env","REACT_APP_N8N_BASE_URL","USE_TEST_WEBHOOKS","REACT_APP_USE_TEST_WEBHOOKS","DEV_MODE","REACT_APP_DEV_MODE","USE_MOCK_MODE","console","log","NODE_ENV","N8nApiService","constructor","baseURL","useTestWebhooks","makeRequest","endpoint","data","baseUrl","endsWith","slice","targetUrl","n8nBaseUrl","payload","JSON","stringify","getMockResponse","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","method","headers","body","signal","clearTimeout","ok","errorText","text","error","status","warn","info","Error","statusText","responseText","trim","result","parse","parseError","finalResult","Array","isArray","success","channel","videos","transformYouTubeResponse","items","message","includes","name","_data$title","_data$userInfo","id","title","description","subscriberCount","videoCount","videoId","publishedAt","Date","now","toISOString","thumbnail","prefillData","subtitle","summary","author","link","language","itunesCategories","explicit","podcastType","imageFile","podcastId","podcast","primaryCategory","secondaryCategory","copyright","ownerName","ownerEmail","websiteUrl","keywords","slug","toLowerCase","replace","createdAt","feedUrl","episodes_count","episodeCount","episodes","duration","playCount","downloadCount","fileUrl","totalCount","videoIds","results","map","episodeId","total","length","successful","failed","episodesSaved","created_at","userId","userInfo","rawData","_firstVideo$snippet$t","_firstVideo$snippet$t2","_firstVideo$snippet$t3","_firstVideo$snippet$t4","_firstVideo$snippet$t5","_firstVideo$snippet$t6","playlistData","firstVideo","snippet","channelId","channelTitle","pageInfo","totalResults","toString","thumbnails","high","url","medium","default","item","_item$snippet$thumbna","_item$snippet$thumbna2","_item$snippet$thumbna3","_item$snippet$thumbna4","_item$snippet$thumbna5","_item$snippet$thumbna6","_item$snippet$thumbna7","_item$snippet$thumbna8","resourceId","maxres","position","getFullYear","transformedResponse","hasPreffillData","_rawData$","_rawData$$items","syncYouTubeChannel","accessToken","substring","_result$channel","createPodcast","podcastData","_podcastData$customAr","podcastPayload","finalArtworkUrl","backgroundImageFileUrl","customArtwork","supabaseUrl","_result$payout","_result$ids","megaphoneResponse","ids","supabaseId","supabasePodcast","supabasePodcastId","supabaseError","airwallexError","payout","warning","payoutData","error_message","payoutSaveError","payoutSetupIncomplete","payoutError","airwallexBeneficiaryId","syncPodcastDataFromMegaphone","syncMegaphoneEpisodes","fetchEpisodes","_result$episodes","createEpisodes","testWebhookUrl","saveToSupabase","mockResult","_result","_result2","setupUser","googleToken","healthCheck","webhookPath","healthUrl","n8nApi"],"sources":["/Users/harshdeshmukh/YouTube To Mp4 Links/src/services/n8nApi.js"],"sourcesContent":["// Clean n8n API service - replaces all direct API calls\nimport { toast } from 'react-toastify';\nimport { savePodcastDetails, savePayoutDetails } from './supabase';\n\n// n8n Configuration\nconst N8N_BASE_URL = process.env.REACT_APP_N8N_BASE_URL || 'https://n8n-6s78.onrender.com/';\nconst USE_TEST_WEBHOOKS = process.env.REACT_APP_USE_TEST_WEBHOOKS !== 'false'; // Default to true for testing\nconst DEV_MODE = process.env.REACT_APP_DEV_MODE === 'true';\n// Use mock mode only if explicitly enabled\nconst USE_MOCK_MODE = DEV_MODE;\n\nconsole.log('üîß n8n API Configuration:', {\n  N8N_BASE_URL,\n  USE_TEST_WEBHOOKS,\n  REACT_APP_DEV_MODE: process.env.REACT_APP_DEV_MODE,\n  NODE_ENV: process.env.NODE_ENV,\n  DEV_MODE,\n  USE_MOCK_MODE\n});\n\nclass N8nApiService {\n  constructor() {\n    this.baseURL = N8N_BASE_URL;\n    this.useTestWebhooks = USE_TEST_WEBHOOKS;\n  }\n\n  async makeRequest(endpoint, data) {\n    // Use direct n8n webhook URL - use test webhooks to avoid CORS issues\n    const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n    const targetUrl = `${baseUrl}/webhook-test/${endpoint}`;\n      \n    console.log(`üì° Making request to endpoint: ${endpoint}`, {\n      USE_MOCK_MODE,\n      DEV_MODE,\n      n8nBaseUrl: baseUrl,\n      targetUrl,\n      payload: data\n    });\n    \n    // Log the exact data being sent for debugging\n    console.log(`üîç Webhook payload for ${endpoint}:`, JSON.stringify(data, null, 2));\n    \n    // Use mock mode if explicitly enabled\n    if (USE_MOCK_MODE) {\n      console.log(`üß™ Using mock response for ${endpoint}`);\n      return this.getMockResponse(endpoint, data);\n    }\n    \n    try {\n      console.log(`üåê Calling n8n PRODUCTION webhook: ${targetUrl}`);\n      \n      // Add timeout to prevent hanging\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n      \n      const response = await fetch(targetUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error(`‚ùå HTTP ${response.status} error for ${endpoint}:`, errorText);\n        console.error(`üì§ Request was made to: ${targetUrl}`);\n        console.error(`üì¶ Request payload was:`, JSON.stringify(data, null, 2));\n        \n        // For 404 errors in dev mode, fall back to mock (workflow not configured)  \n        if (DEV_MODE && response.status === 404) {\n          console.warn('üîÑ n8n workflow not found, falling back to mock response');\n          toast.info('Using offline mode - n8n workflow not configured');\n          return this.getMockResponse(endpoint, data);\n        }\n        \n        // Only fall back to mock for server errors in dev mode\n        if (DEV_MODE && response.status >= 500) {\n          console.warn('Server error in dev mode, falling back to mock response');\n          return this.getMockResponse(endpoint, data);\n        }\n        \n        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);\n      }\n\n      // Check if response has content before parsing JSON\n      const responseText = await response.text();\n      console.log(`üì• Raw response from ${endpoint}:`, responseText);\n      \n      if (!responseText || responseText.trim() === '') {\n        console.warn(`‚ö†Ô∏è Empty response from ${endpoint}, falling back to mock`);\n        toast.info('Webhook returned empty response - using offline mode');\n        return this.getMockResponse(endpoint, data);\n      }\n      \n      let result;\n      try {\n        result = JSON.parse(responseText);\n        console.log(`‚úÖ Parsed JSON from ${endpoint}:`, result);\n      } catch (parseError) {\n        console.error(`‚ùå JSON parse error for ${endpoint}:`, parseError);\n        console.error(`üìù Response text was:`, responseText);\n        console.warn('üîÑ Falling back to mock response due to parse error');\n        toast.info('Webhook returned invalid response - using offline mode');\n        return this.getMockResponse(endpoint, data);\n      }\n      \n      // Handle N8N array response format\n      const finalResult = Array.isArray(result) ? result[0] : result;\n      console.log(`Processed response:`, finalResult);\n      \n      // Handle different response formats from n8n workflow\n      if (endpoint === 'youtube-sync') {\n        // Check if it's already in the expected format\n        if (finalResult.success && finalResult.channel && finalResult.videos) {\n          console.log('‚úÖ Received properly formatted YouTube sync response');\n          return finalResult;\n        }\n        \n        // Handle raw YouTube API response format\n        if (Array.isArray(finalResult) && !finalResult.success) {\n          console.warn('‚ö†Ô∏è n8n returned raw YouTube data, transforming...');\n          return this.transformYouTubeResponse(finalResult);\n        }\n        \n        // Handle single object response format\n        if (finalResult.channel || finalResult.videos || finalResult.items) {\n          console.warn('‚ö†Ô∏è n8n returned partial data format, transforming...');\n          return this.transformYouTubeResponse([finalResult]);\n        }\n      }\n      \n      return finalResult;\n    } catch (error) {\n      console.error(`n8n API error for ${endpoint}:`, error);\n      \n      // Fall back to mock for network/CORS failures (common in development)\n      if (error.message.includes('Failed to fetch') || \n          error.message.includes('NetworkError') ||\n          error.message.includes('CORS') ||\n          error.name === 'AbortError' ||\n          error.message.includes('fetch')) {\n        console.warn('üîÑ Network/CORS error, falling back to mock response');\n        toast.info('Using offline mode - n8n server not available or CORS issue');\n        return this.getMockResponse(endpoint, data);\n      }\n      \n      // Better error messages\n      if (error.message.includes('HTTP 404')) {\n        throw new Error('Workflow not found. Please ensure n8n workflows are properly set up.');\n      } else if (error.message.includes('HTTP 500')) {\n        throw new Error('Server error occurred. Please try again in a moment.');\n      } else {\n        throw new Error(`n8n workflow failed: ${error.message}`);\n      }\n    }\n  }\n  \n  // Mock responses for development\n  getMockResponse(endpoint, data) {\n    console.log(`üß™ Using mock response for ${endpoint}`);\n    \n    switch (endpoint) {\n      case 'youtube-sync':\n        return {\n          success: true,\n          channel: {\n            id: 'UC_mock_channel_id',\n            title: 'Mock YouTube Channel',\n            description: 'This is a mock YouTube channel for testing purposes.',\n            subscriberCount: '1234',\n            videoCount: '42'\n          },\n          videos: [\n            {\n              videoId: 'mock_video_1',\n              title: 'Mock Video 1: Introduction to PodPay',\n              description: 'Learn how to use PodPay to convert YouTube videos to podcasts.',\n              publishedAt: new Date(Date.now() - 86400000).toISOString(),\n              thumbnail: 'https://via.placeholder.com/120x90/4F46E5/FFFFFF?text=Video+1'\n            },\n            {\n              videoId: 'mock_video_2', \n              title: 'Mock Video 2: Advanced Features',\n              description: 'Explore advanced features of podcast creation.',\n              publishedAt: new Date(Date.now() - 172800000).toISOString(),\n              thumbnail: 'https://via.placeholder.com/120x90/7C3AED/FFFFFF?text=Video+2'\n            },\n            {\n              videoId: 'mock_video_3',\n              title: 'Mock Video 3: Monetization Tips',\n              description: 'Tips and tricks for monetizing your podcast.',\n              publishedAt: new Date(Date.now() - 259200000).toISOString(),\n              thumbnail: 'https://via.placeholder.com/120x90/059669/FFFFFF?text=Video+3'\n            }\n          ],\n          message: 'Mock YouTube channel data fetched successfully - ready for podcast creation form',\n          prefillData: {\n            title: 'Mock YouTube Channel Podcast',\n            subtitle: 'Podcast created from Mock YouTube Channel',\n            summary: 'This is a mock YouTube channel for testing purposes.',\n            author: 'Mock YouTube Channel',\n            link: 'https://www.youtube.com/channel/UC_mock_channel_id',\n            language: 'en',\n            itunesCategories: ['Technology'],\n            explicit: 'clean',\n            podcastType: 'serial',\n            imageFile: 'https://via.placeholder.com/300x300/4F46E5/FFFFFF?text=Mock+Channel'\n          }\n        };\n        \n      case 'create-podcast':\n        return {\n          success: true,\n          podcastId: 'mock_podcast_' + Date.now(),\n          podcast: {\n            id: 'mock_podcast_' + Date.now(),\n            title: data.title || 'Mock Podcast',\n            description: data.description || 'Mock podcast description',\n            author: data.author || 'Mock Author',\n            language: data.language || 'en',\n            explicit: data.explicit || 'clean',\n            primaryCategory: data.primaryCategory || 'Technology',\n            secondaryCategory: data.secondaryCategory || '',\n            podcastType: data.podcastType || 'serial',\n            link: data.link || 'https://youtube.com/channel/mock',\n            copyright: data.copyright || '¬© 2024 Mock Author',\n            ownerName: data.ownerName || 'Mock Author',\n            ownerEmail: data.ownerEmail || 'mock@example.com',\n            websiteUrl: data.websiteUrl || 'https://youtube.com/channel/mock',\n            keywords: data.keywords || 'mock, podcast, youtube',\n            slug: data.title?.toLowerCase().replace(/[^a-z0-9]+/g, '-') || 'mock-podcast',\n            createdAt: new Date().toISOString(),\n            feedUrl: `https://feeds.megaphone.fm/mock_podcast_${Date.now()}`\n          },\n          message: 'Mock podcast created successfully!'\n        };\n        \n      case 'sync-podcast-data':\n        return {\n          success: true,\n          podcast: {\n            title: 'Harsh ‚òÄÔ∏è Podcast',\n            subtitle: 'Updated from Megaphone',\n            summary: 'Fresh podcast data synced from Megaphone API',\n            episodes_count: 0,\n            status: 'active'\n          },\n          message: 'Podcast data synced from Megaphone'\n        };\n\n      case 'sync-megaphone-episodes':\n        return {\n          success: true,\n          episodeCount: 0,\n          episodes: [],\n          message: 'No episodes found in Megaphone for this podcast'\n        };\n\n      case 'fetch-episodes':\n        return {\n          success: true,\n          episodes: [\n            {\n              id: 'episode_1',\n              title: 'Sample Published Episode 1',\n              summary: 'This is a sample episode summary',\n              publishedAt: '2025-01-20T10:00:00Z',\n              duration: 1800, // 30 minutes in seconds\n              status: 'published',\n              playCount: 1234,\n              downloadCount: 567,\n              fileUrl: 'https://example.com/episode1.mp3'\n            },\n            {\n              id: 'episode_2', \n              title: 'Sample Published Episode 2',\n              summary: 'This is another sample episode summary',\n              publishedAt: '2025-01-15T10:00:00Z',\n              duration: 2100, // 35 minutes in seconds\n              status: 'published',\n              playCount: 987,\n              downloadCount: 432,\n              fileUrl: 'https://example.com/episode2.mp3'\n            }\n          ],\n          totalCount: 2\n        };\n        \n      case 'create-episodes':\n        const videoIds = data.videoIds || [];\n        return {\n          success: true,\n          results: videoIds.map(videoId => ({\n            videoId,\n            episodeId: `mock_episode_${videoId}`,\n            status: 'created',\n            title: `Mock Episode for ${videoId}`\n          })),\n          summary: {\n            total: videoIds.length,\n            successful: videoIds.length,\n            failed: 0\n          },\n          episodesSaved: videoIds.map(videoId => ({\n            id: `episode_${videoId}`,\n            title: `Episode from video ${videoId}`,\n            status: 'published',\n            created_at: new Date().toISOString()\n          }))\n        };\n        \n      case 'user-setup':\n        return {\n          success: true,\n          userId: data.userInfo?.id || 'mock_user_123',\n          message: 'Mock user setup completed'\n        };\n        \n      default:\n        return {\n          success: true,\n          message: `Mock response for ${endpoint}`\n        };\n    }\n  }\n  \n  // Transform raw YouTube API response into expected format\n  transformYouTubeResponse(rawData) {\n    console.log('üîÑ Transforming raw YouTube response to expected format');\n    \n    try {\n      // Extract the first item which contains the playlist data\n      const playlistData = rawData[0];\n      \n      if (!playlistData || !playlistData.items) {\n        throw new Error('Invalid YouTube response structure');\n      }\n      \n      // Extract channel info from the first video\n      const firstVideo = playlistData.items[0];\n      if (!firstVideo) {\n        throw new Error('No videos found in playlist');\n      }\n      \n      // Create channel object\n      const channel = {\n        id: firstVideo.snippet.channelId,\n        title: firstVideo.snippet.channelTitle,\n        description: `YouTube channel with ${playlistData.pageInfo.totalResults} videos`,\n        subscriberCount: 'N/A', // Not available in playlist response\n        videoCount: playlistData.pageInfo.totalResults.toString(),\n        thumbnail: firstVideo.snippet.thumbnails?.high?.url || \n                  firstVideo.snippet.thumbnails?.medium?.url || \n                  firstVideo.snippet.thumbnails?.default?.url\n      };\n      \n      // Transform videos\n      const videos = playlistData.items.map(item => ({\n        videoId: item.snippet.resourceId.videoId,\n        title: item.snippet.title,\n        description: item.snippet.description,\n        publishedAt: item.snippet.publishedAt,\n        thumbnail: item.snippet.thumbnails?.maxres?.url || \n                  item.snippet.thumbnails?.high?.url || \n                  item.snippet.thumbnails?.medium?.url || \n                  item.snippet.thumbnails?.default?.url,\n        position: item.snippet.position\n      }));\n      \n      // Create prefill data with Megaphone-compatible fields\n      const prefillData = {\n        title: channel.title + ' Podcast',\n        subtitle: `Podcast created from ${channel.title} YouTube channel`, // New Megaphone field\n        summary: channel.description || `Podcast created from ${channel.title} YouTube channel with ${channel.videoCount} videos.`, // Megaphone uses 'summary'\n        author: channel.title,\n        link: `https://www.youtube.com/channel/${channel.id}`,\n        language: 'en',\n        itunesCategories: ['Technology'], // Convert to iTunes categories array\n        explicit: 'clean', // Megaphone enum: no/clean/yes\n        podcastType: 'serial',\n        copyright: `¬© ${new Date().getFullYear()} ${channel.title}`,\n        ownerName: channel.title,\n        ownerEmail: '', // User will need to fill this\n        imageFile: channel.thumbnail || '', // Megaphone uses 'imageFile' instead of 'artworkUrl'\n        keywords: 'youtube, podcast, ' + channel.title.toLowerCase().replace(/\\s+/g, ', ')\n      };\n      \n      const transformedResponse = {\n        success: true,\n        channel,\n        videos,\n        message: 'YouTube channel data fetched successfully - ready for podcast creation form',\n        prefillData\n      };\n      \n      console.log('‚úÖ Successfully transformed YouTube response:', {\n        channelTitle: channel.title,\n        videoCount: videos.length,\n        hasPreffillData: !!prefillData\n      });\n      \n      return transformedResponse;\n      \n    } catch (error) {\n      console.error('‚ùå Failed to transform YouTube response:', error);\n      \n      // Return fallback response\n      return {\n        success: true,\n        channel: {\n          id: 'unknown',\n          title: 'YouTube Channel',\n          description: 'Channel data retrieved from YouTube',\n          subscriberCount: 'N/A',\n          videoCount: Array.isArray(rawData) && rawData[0]?.items?.length ? rawData[0].items.length.toString() : '0'\n        },\n        videos: [],\n        message: 'YouTube channel data retrieved (with limited info)',\n        prefillData: {\n          title: 'My YouTube Podcast',\n          subtitle: 'Podcast created from YouTube channel',\n          summary: 'Podcast created from YouTube channel content',\n          author: 'YouTube Creator',\n          link: 'https://youtube.com',\n          language: 'en',\n          itunesCategories: ['Technology'],\n          explicit: 'clean',\n          podcastType: 'serial',\n          imageFile: ''\n        }\n      };\n    }\n  }\n\n  // YouTube Channel Sync - fetches channel data for form prefill\n  async syncYouTubeChannel(accessToken, userId) {\n    try {\n      console.log(`üéØ syncYouTubeChannel called with:`, {\n        accessToken: accessToken ? `${accessToken.substring(0, 10)}...` : 'NULL',\n        userId: userId || 'NULL'\n      });\n      \n      toast.info('Fetching your YouTube channel data...');\n      \n      const result = await this.makeRequest('youtube-sync', {\n        accessToken,\n        userId\n      });\n      \n      if (result.success) {\n        const channelTitle = result.channel?.title || 'Your Channel';\n        toast.success(`Channel \"${channelTitle}\" data fetched successfully!`);\n        return result;\n      } else {\n        throw new Error(result.error || result.message || 'Channel sync failed');\n      }\n    } catch (error) {\n      console.error('YouTube channel sync failed:', error);\n      throw error;\n    }\n  }\n\n  // Create Podcast - creates podcast after user fills form\n  async createPodcast(podcastData) {\n    try {\n      toast.info('Creating your podcast...');\n      \n      // Ensure all required data is included\n      const podcastPayload = {\n        ...podcastData,\n        // Add timestamp for uniqueness\n        createdAt: new Date().toISOString(),\n        // Ensure required fields have defaults\n        language: podcastData.language || 'en',\n        explicit: podcastData.explicit || 'clean',\n        podcastType: podcastData.podcastType || 'serial',\n        primaryCategory: podcastData.primaryCategory || 'Technology',\n        // Ensure imageFile is set from the best available source\n        imageFile: podcastData.imageFile || podcastData.finalArtworkUrl || podcastData.backgroundImageFileUrl || (podcastData.customArtwork?.supabaseUrl)\n      };\n      \n      console.log('Creating podcast with payload:', podcastPayload);\n      console.log('üì∏ Image data being sent to n8n:', {\n        imageFile: podcastPayload.imageFile,\n        backgroundImageFileUrl: podcastPayload.backgroundImageFileUrl,\n        finalArtworkUrl: podcastPayload.finalArtworkUrl\n      });\n      \n      const result = await this.makeRequest('create-podcast', podcastPayload);\n      \n      if (result.success) {\n        // Save podcast details to Supabase (if not already saved via N8N workflow)\n        try {\n          const userId = podcastPayload.userId;\n          const megaphoneResponse = result.podcast || result.megaphoneResponse;\n          \n          // Only save to Supabase if N8N didn't already handle it\n          if (megaphoneResponse && !result.ids?.supabaseId) {\n            console.log('üíæ Saving podcast to Supabase...', megaphoneResponse);\n            const supabasePodcast = await savePodcastDetails(userId, podcastPayload, megaphoneResponse);\n            \n            // Store Supabase podcast ID for payout linking\n            result.supabasePodcastId = supabasePodcast.id;\n            result.supabasePodcast = supabasePodcast;\n            \n            console.log('‚úÖ Podcast saved to Supabase:', supabasePodcast.id);\n          } else {\n            console.log('‚úÖ Podcast already saved to Supabase via N8N workflow');\n          }\n        } catch (supabaseError) {\n          console.error('‚ùå Failed to save podcast to Supabase:', supabaseError);\n          // Continue with workflow - sometimes the save actually succeeds despite error message\n          console.log('‚ÑπÔ∏è Check Supabase directly - data might have saved successfully');\n        }\n\n        // Check if there were any Airwallex errors but still continue\n        if (result.airwallexError || result.payout?.status === 'incomplete') {\n          console.warn('‚ö†Ô∏è Airwallex beneficiary creation failed:', result.airwallexError);\n          toast.warning('Podcast created! Payout setup needs attention - check dashboard later.');\n          \n          // Save failed payout details to Supabase if we have podcast ID\n          if (result.supabasePodcastId && podcastPayload.payoutData) {\n            try {\n              await savePayoutDetails(\n                podcastPayload.userId, \n                result.supabasePodcastId, \n                {\n                  ...podcastPayload.payoutData,\n                  status: 'error',\n                  error_message: result.airwallexError\n                }\n              );\n            } catch (payoutSaveError) {\n              console.error('‚ùå Failed to save payout error to Supabase:', payoutSaveError);\n            }\n          }\n          \n          return {\n            ...result,\n            payoutSetupIncomplete: true,\n            payoutError: result.airwallexError\n          };\n        } else {\n          // Save successful payout details to Supabase\n          if (result.supabasePodcastId && podcastPayload.payoutData && result.airwallexBeneficiaryId) {\n            try {\n              await savePayoutDetails(\n                podcastPayload.userId, \n                result.supabasePodcastId, \n                {\n                  ...podcastPayload.payoutData,\n                  airwallexBeneficiaryId: result.airwallexBeneficiaryId,\n                  status: 'active'\n                }\n              );\n              console.log('‚úÖ Payout details saved to Supabase');\n            } catch (payoutSaveError) {\n              console.error('‚ùå Failed to save payout details to Supabase:', payoutSaveError);\n            }\n          }\n          \n          toast.success(`Podcast \"${podcastData.title}\" created successfully!`);\n        }\n        return result;\n      } else {\n        throw new Error(result.error || result.message || 'Podcast creation failed');\n      }\n    } catch (error) {\n      console.error('Podcast creation failed:', error);\n      throw error;\n    }\n  }\n\n  // Podcast Data Sync Methods\n  async syncPodcastDataFromMegaphone(userId) {\n    try {\n      console.log('üîÑ syncPodcastDataFromMegaphone called for user:', userId);\n      \n      const result = await this.makeRequest('sync-podcast-data', {\n        userId\n      });\n      \n      if (result.success) {\n        console.log(`‚úÖ Synced podcast data from Megaphone:`, result.podcast);\n        return {\n          success: true,\n          podcast: result.podcast,\n          message: result.message || 'Podcast data synced successfully'\n        };\n      } else {\n        throw new Error(result.error || 'Failed to sync podcast data from Megaphone');\n      }\n      \n    } catch (error) {\n      console.warn('‚ö†Ô∏è Podcast data sync failed (non-critical):', error.message);\n      \n      // Return success for missing webhooks to avoid blocking auth flow\n      if (error.message.includes('Failed to fetch') || \n          error.message.includes('CORS') ||\n          error.message.includes('404')) {\n        console.log('üìù Sync webhook not available, skipping sync (this is okay)');\n        return {\n          success: true,\n          message: 'Podcast sync skipped - webhook not available'\n        };\n      }\n      \n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Episode Management Methods\n  async syncMegaphoneEpisodes(podcastId, userId) {\n    try {\n      console.log('üîÑ syncMegaphoneEpisodes called with:', { podcastId, userId });\n      \n      const result = await this.makeRequest('sync-megaphone-episodes', {\n        podcastId,\n        userId\n      });\n      \n      if (result.success) {\n        console.log(`‚úÖ Synced ${result.episodeCount || 0} episodes from Megaphone`);\n        return {\n          success: true,\n          episodes: result.episodes || [],\n          episodeCount: result.episodeCount || 0,\n          message: result.message || 'Episodes synced successfully'\n        };\n      } else {\n        throw new Error(result.error || 'Failed to sync episodes from Megaphone');\n      }\n      \n    } catch (error) {\n      console.warn('‚ö†Ô∏è Megaphone episodes sync failed (non-critical):', error.message);\n      \n      // Return empty episodes list for missing webhooks\n      if (error.message.includes('Failed to fetch') || \n          error.message.includes('CORS') ||\n          error.message.includes('404')) {\n        console.log('üìù Megaphone sync webhook not available, returning empty episodes');\n        return {\n          success: true,\n          episodes: [],\n          episodeCount: 0,\n          message: 'Megaphone sync skipped - webhook not available'\n        };\n      }\n      \n      return {\n        success: false,\n        error: error.message,\n        episodes: []\n      };\n    }\n  }\n\n  async fetchEpisodes(podcastId, userId) {\n    try {\n      console.log('üéØ fetchEpisodes called with:', { podcastId, userId });\n      \n      const result = await this.makeRequest('fetch-episodes', {\n        podcastId,\n        userId\n      });\n      \n      if (result.success) {\n        console.log(`‚úÖ Fetched ${result.episodes?.length || 0} episodes from Megaphone`);\n        return {\n          success: true,\n          episodes: result.episodes || [],\n          totalCount: result.totalCount || 0\n        };\n      } else {\n        throw new Error(result.error || 'Failed to fetch episodes');\n      }\n      \n    } catch (error) {\n      console.warn('‚ö†Ô∏è Fetch episodes failed (non-critical):', error.message);\n      \n      // Return empty episodes list for missing webhooks\n      if (error.message.includes('Failed to fetch') || \n          error.message.includes('CORS') ||\n          error.message.includes('404')) {\n        console.log('üìù Fetch episodes webhook not available, returning empty episodes');\n        return {\n          success: true,\n          episodes: [],\n          totalCount: 0,\n          message: 'Episode fetch skipped - webhook not available'\n        };\n      }\n      \n      return {\n        success: false,\n        error: error.message,\n        episodes: []\n      };\n    }\n  }\n\n  // Episode Creation - creates episodes and saves to Supabase\n  async createEpisodes(podcastId, videoIds, userId) {\n    console.log('üî• createEpisodes function called with:', { podcastId, videoIds, userId });\n    \n    try {\n      // Validate inputs\n      if (!podcastId) {\n        throw new Error('No podcastId provided');\n      }\n      if (!videoIds || videoIds.length === 0) {\n        throw new Error('No videoIds provided');\n      }\n      if (!userId) {\n        throw new Error('No userId provided');\n      }\n      \n      toast.info(`Creating ${videoIds.length} episodes and saving to database...`);\n      \n      // For create-episodes, use the test webhook endpoint directly\n      const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n      const testWebhookUrl = `${baseUrl}/webhook-test/create-episodes`;\n      \n      console.log('üì§ Sending episode creation request to:', testWebhookUrl);\n      console.log('üìã Payload:', { podcastId, videoIds, userId });\n      \n      // Check if we should use mock mode\n      if (USE_MOCK_MODE) {\n        console.log('üß™ Using mock response for create-episodes');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n      \n      const response = await fetch(testWebhookUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        })\n      });\n      \n      console.log('üì° Response status:', response.status);\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('‚ùå HTTP Error:', response.status, errorText);\n        \n        // If webhook doesn't exist (404), fall back to mock data\n        if (response.status === 404 || DEV_MODE) {\n          console.warn('üîÑ Test webhook not found or in dev mode, using mock response');\n          const result = this.getMockResponse('create-episodes', {\n            podcastId,\n            videoIds,\n            userId,\n            saveToSupabase: true\n          });\n          return result;\n        }\n        \n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const responseText = await response.text();\n      console.log('üì• Raw response:', responseText);\n      \n      if (!responseText || responseText.trim() === '') {\n        console.warn('‚ö†Ô∏è Empty response from webhook, using mock data');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n      \n      let result;\n      try {\n        result = JSON.parse(responseText);\n        console.log('‚úÖ Episode creation response:', result);\n      } catch (parseError) {\n        console.error('‚ùå JSON parse error:', parseError);\n        console.warn('üîÑ Using mock response due to parse error');\n        const result = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return result;\n      }\n      \n      // Handle n8n workflow started response\n      if (result.message === 'Workflow was started' || !result.success) {\n        console.warn('üîÑ n8n workflow started but no detailed response - using mock fallback');\n        toast.info('Episode creation workflow started - using mock response for now');\n        const mockResult = this.getMockResponse('create-episodes', {\n          podcastId,\n          videoIds,\n          userId,\n          saveToSupabase: true\n        });\n        return mockResult;\n      }\n      \n      console.log('‚úÖ Episode creation response:', result);\n      \n      if (result && result.success) {\n        const { successful, failed, total } = result.summary || { successful: videoIds.length, failed: 0, total: videoIds.length };\n        \n        if (successful > 0) {\n          toast.success(`${successful}/${total} episodes created and saved to database!`);\n        }\n        if (failed > 0) {\n          toast.warning(`${failed}/${total} episodes failed to create`);\n        }\n        \n        // Also sync existing episodes to ensure we have everything\n        setTimeout(() => {\n          this.syncMegaphoneEpisodes(podcastId, userId);\n        }, 2000);\n        \n        const finalResult = {\n          ...result,\n          episodesSaved: result.episodesSaved || []\n        };\n        console.log('üéâ createEpisodes returning success result:', finalResult);\n        return finalResult;\n      } else {\n        console.error('‚ùå Episode creation result was not successful:', result);\n        throw new Error(result?.error || result?.message || 'Episode creation failed');\n      }\n    } catch (error) {\n      console.error('üö® createEpisodes function error:', error);\n      toast.error(`Episode creation failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  // User Setup - handles user data storage\n  async setupUser(googleToken, userInfo) {\n    try {\n      console.log('Setting up user with n8n...');\n      \n      const result = await this.makeRequest('user-setup', {\n        googleToken,\n        userInfo\n      });\n      \n      if (result.success) {\n        console.log('User setup completed:', result);\n        return result;\n      } else {\n        throw new Error(result.error || 'User setup failed');\n      }\n    } catch (error) {\n      console.error('User setup failed:', error);\n      // Don't show error toast for user setup - it's background\n      throw error;\n    }\n  }\n\n  // Health check for n8n connection\n  async healthCheck() {\n    // Mock mode always returns healthy\n    if (USE_MOCK_MODE) {\n      return true;\n    }\n    \n    try {\n      // Use production webhooks for health check\n      const webhookPath = 'webhook';\n      const baseUrl = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;\n      const healthUrl = `${baseUrl}/${webhookPath}/health`;\n      const response = await fetch(healthUrl);\n      return response.ok;\n    } catch {\n      // Fall back to mock mode if health check fails\n      return true; // Allow the app to work with mocks\n    }\n  }\n}\n\n// Export singleton instance\nexport const n8nApi = new N8nApiService();\n\n// Export individual functions for convenience\nexport const syncYouTubeChannel = (accessToken, userId) => \n  n8nApi.syncYouTubeChannel(accessToken, userId);\n\nexport const createPodcast = (podcastData) => \n  n8nApi.createPodcast(podcastData);\n\nexport const syncPodcastDataFromMegaphone = (userId) => \n  n8nApi.syncPodcastDataFromMegaphone(userId);\nexport const syncMegaphoneEpisodes = (podcastId, userId) => \n  n8nApi.syncMegaphoneEpisodes(podcastId, userId);\nexport const fetchEpisodes = (podcastId, userId) => \n  n8nApi.fetchEpisodes(podcastId, userId);\nexport const createEpisodes = (podcastId, videoIds, userId) => \n  n8nApi.createEpisodes(podcastId, videoIds, userId);\n\nexport const setupUser = (googleToken, userInfo) => \n  n8nApi.setupUser(googleToken, userInfo);\n\nexport default n8nApi;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}