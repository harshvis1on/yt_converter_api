{"ast":null,"code":"// Megaphone API Service for fetching episode status and data via n8n proxy\nimport { n8nApi } from './n8nApi';\nclass MegaphoneApiService {\n  constructor() {\n    this.apiToken = process.env.REACT_APP_MEGAPHONE_API_TOKEN;\n    this.networkId = process.env.REACT_APP_MEGAPHONE_NETWORK_ID;\n  }\n\n  // Fetch episode details via n8n proxy (to avoid CORS issues)\n  async getEpisodeStatus(podcastId, episodeId) {\n    if (!this.apiToken || !this.networkId) {\n      console.warn('âš ï¸ Megaphone API credentials not configured');\n      return null;\n    }\n    try {\n      console.log(`ðŸŽ§ Fetching episode status via n8n proxy:`, {\n        podcastId,\n        episodeId\n      });\n\n      // Call n8n workflow that will proxy the Megaphone API request\n      const result = await n8nApi.makeRequest('get-episode-status', {\n        podcastId: podcastId,\n        episodeId: episodeId,\n        apiToken: this.apiToken\n      });\n      if (!result || !result.success) {\n        console.warn(`ðŸ“» Episode ${episodeId} not found or API error`);\n        return null;\n      }\n      console.log(`âœ… Retrieved episode data via n8n:`, result.episode);\n\n      // Transform Megaphone status to our UI status\n      const status = this.transformMegaphoneStatus(result.episode.status);\n      return {\n        status,\n        originalStatus: result.episode.status,\n        publishedAt: result.episode.published_at,\n        createdAt: result.episode.created_at,\n        updatedAt: result.episode.updated_at,\n        title: result.episode.title,\n        summary: result.episode.summary,\n        uid: result.episode.uid,\n        rawData: result.episode\n      };\n    } catch (error) {\n      console.error(`âŒ Failed to fetch episode status via n8n:`, error);\n      return null;\n    }\n  }\n\n  // Transform Megaphone status to UI-friendly status\n  transformMegaphoneStatus(megaphoneStatus) {\n    if (!megaphoneStatus) return 'Processing';\n    switch (megaphoneStatus.toLowerCase()) {\n      case 'published':\n        return 'Live';\n      case 'scheduled':\n        return 'Scheduled';\n      case 'draft':\n        return 'Draft';\n      case 'processing':\n        return 'Processing';\n      default:\n        console.log(`ðŸ” Unknown Megaphone status: \"${megaphoneStatus}\"`);\n        return 'Processing';\n    }\n  }\n\n  // Fetch multiple episodes status in parallel\n  async getMultipleEpisodeStatus(episodes) {\n    if (!episodes || episodes.length === 0) return [];\n    console.log(`ðŸŽ§ Fetching status for ${episodes.length} episodes from Megaphone API`);\n    const statusPromises = episodes.map(async episode => {\n      if (!episode.megaphoneEpisodeId || !episode.podcastId) {\n        console.warn(`âš ï¸ Missing IDs for episode ${episode.id}:`, {\n          megaphoneEpisodeId: episode.megaphoneEpisodeId,\n          podcastId: episode.podcastId\n        });\n        return {\n          ...episode,\n          megaphoneStatus: null\n        };\n      }\n      const statusData = await this.getEpisodeStatus(episode.podcastId, episode.megaphoneEpisodeId);\n      return {\n        ...episode,\n        megaphoneStatus: statusData\n      };\n    });\n    try {\n      const results = await Promise.allSettled(statusPromises);\n      return results.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        } else {\n          console.error(`âŒ Failed to fetch status for episode ${episodes[index].id}:`, result.reason);\n          return {\n            ...episodes[index],\n            megaphoneStatus: null\n          };\n        }\n      });\n    } catch (error) {\n      console.error('âŒ Error in batch episode status fetch:', error);\n      return episodes.map(episode => ({\n        ...episode,\n        megaphoneStatus: null\n      }));\n    }\n  }\n}\nexport const megaphoneApiService = new MegaphoneApiService();\nexport default megaphoneApiService;","map":{"version":3,"names":["n8nApi","MegaphoneApiService","constructor","apiToken","process","env","REACT_APP_MEGAPHONE_API_TOKEN","networkId","REACT_APP_MEGAPHONE_NETWORK_ID","getEpisodeStatus","podcastId","episodeId","console","warn","log","result","makeRequest","success","episode","status","transformMegaphoneStatus","originalStatus","publishedAt","published_at","createdAt","created_at","updatedAt","updated_at","title","summary","uid","rawData","error","megaphoneStatus","toLowerCase","getMultipleEpisodeStatus","episodes","length","statusPromises","map","megaphoneEpisodeId","id","statusData","results","Promise","allSettled","index","value","reason","megaphoneApiService"],"sources":["/Users/harshdeshmukh/YouTube To Mp4 Links/src/services/megaphoneApi.js"],"sourcesContent":["// Megaphone API Service for fetching episode status and data via n8n proxy\nimport { n8nApi } from './n8nApi';\n\nclass MegaphoneApiService {\n  constructor() {\n    this.apiToken = process.env.REACT_APP_MEGAPHONE_API_TOKEN;\n    this.networkId = process.env.REACT_APP_MEGAPHONE_NETWORK_ID;\n  }\n\n  // Fetch episode details via n8n proxy (to avoid CORS issues)\n  async getEpisodeStatus(podcastId, episodeId) {\n    if (!this.apiToken || !this.networkId) {\n      console.warn('âš ï¸ Megaphone API credentials not configured');\n      return null;\n    }\n\n    try {\n      console.log(`ðŸŽ§ Fetching episode status via n8n proxy:`, { podcastId, episodeId });\n      \n      // Call n8n workflow that will proxy the Megaphone API request\n      const result = await n8nApi.makeRequest('get-episode-status', {\n        podcastId: podcastId,\n        episodeId: episodeId,\n        apiToken: this.apiToken\n      });\n\n      if (!result || !result.success) {\n        console.warn(`ðŸ“» Episode ${episodeId} not found or API error`);\n        return null;\n      }\n\n      console.log(`âœ… Retrieved episode data via n8n:`, result.episode);\n\n      // Transform Megaphone status to our UI status\n      const status = this.transformMegaphoneStatus(result.episode.status);\n      \n      return {\n        status,\n        originalStatus: result.episode.status,\n        publishedAt: result.episode.published_at,\n        createdAt: result.episode.created_at,\n        updatedAt: result.episode.updated_at,\n        title: result.episode.title,\n        summary: result.episode.summary,\n        uid: result.episode.uid,\n        rawData: result.episode\n      };\n\n    } catch (error) {\n      console.error(`âŒ Failed to fetch episode status via n8n:`, error);\n      return null;\n    }\n  }\n\n  // Transform Megaphone status to UI-friendly status\n  transformMegaphoneStatus(megaphoneStatus) {\n    if (!megaphoneStatus) return 'Processing';\n    \n    switch (megaphoneStatus.toLowerCase()) {\n      case 'published':\n        return 'Live';\n      case 'scheduled':\n        return 'Scheduled';\n      case 'draft':\n        return 'Draft';\n      case 'processing':\n        return 'Processing';\n      default:\n        console.log(`ðŸ” Unknown Megaphone status: \"${megaphoneStatus}\"`);\n        return 'Processing';\n    }\n  }\n\n  // Fetch multiple episodes status in parallel\n  async getMultipleEpisodeStatus(episodes) {\n    if (!episodes || episodes.length === 0) return [];\n\n    console.log(`ðŸŽ§ Fetching status for ${episodes.length} episodes from Megaphone API`);\n    \n    const statusPromises = episodes.map(async (episode) => {\n      if (!episode.megaphoneEpisodeId || !episode.podcastId) {\n        console.warn(`âš ï¸ Missing IDs for episode ${episode.id}:`, { \n          megaphoneEpisodeId: episode.megaphoneEpisodeId, \n          podcastId: episode.podcastId \n        });\n        return { ...episode, megaphoneStatus: null };\n      }\n\n      const statusData = await this.getEpisodeStatus(episode.podcastId, episode.megaphoneEpisodeId);\n      return {\n        ...episode,\n        megaphoneStatus: statusData\n      };\n    });\n\n    try {\n      const results = await Promise.allSettled(statusPromises);\n      return results.map((result, index) => {\n        if (result.status === 'fulfilled') {\n          return result.value;\n        } else {\n          console.error(`âŒ Failed to fetch status for episode ${episodes[index].id}:`, result.reason);\n          return { ...episodes[index], megaphoneStatus: null };\n        }\n      });\n    } catch (error) {\n      console.error('âŒ Error in batch episode status fetch:', error);\n      return episodes.map(episode => ({ ...episode, megaphoneStatus: null }));\n    }\n  }\n}\n\nexport const megaphoneApiService = new MegaphoneApiService();\nexport default megaphoneApiService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}